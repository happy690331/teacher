<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDF è€ƒå·ç²¾æº–é»è®€ç³»çµ±</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- PDF.js viewer CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" />

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #525659;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        /* éš±è—æ»¾å‹•æ¢ä½†ä¿ç•™åŠŸèƒ½ */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: #333; }
        ::-webkit-scrollbar-thumb { background: #666; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #888; }

        /* PDF é é¢å®¹å™¨ */
        .pdf-page-wrapper {
            position: relative;
            margin: 20px auto;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            background-color: white;
        }

        /* Text Layer è¨­å®š */
        .textLayer {
            opacity: 1;
            mix-blend-mode: multiply;
        }

        .textLayer span {
            color: transparent;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        /* æ»‘é¼ ç¶“éå–®å€‹æ–‡å­—æ™‚çš„æç¤º (æ·ºç°) */
        .textLayer span:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        /* è¢«é¸ä¸­æœ—è®€çš„é¡Œç›® (ç²¾ç¢ºé»ƒè‰²é«˜äº®) */
        .textLayer span.reading-highlight {
            background-color: rgba(255, 240, 0, 0.5) !important; /* é¡¯çœ¼çš„é»ƒè‰² */
            box-shadow: 0 0 2px rgba(255, 200, 0, 0.5);
        }

        /* è¼‰å…¥å‹•ç•« */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- é ‚éƒ¨æµ®å‹•å·¥å…·åˆ— -->
    <header class="bg-gray-800 text-white shadow-md z-50 flex-none px-4 py-3 flex items-center justify-between">
        <div class="flex items-center gap-3">
            <span class="text-2xl">ğŸ“„</span>
            <h1 class="text-lg font-medium tracking-wide">è€ƒå·é»è®€æ¨¡å¼ (é˜²å¹²æ“¾ä¿®æ­£ç‰ˆ)</h1>
        </div>
        
        <div class="flex items-center gap-4">
            <div id="statusMsg" class="text-sm text-gray-300 hidden flex items-center gap-2"></div>

            <button id="stopBtn" class="hidden bg-red-500 hover:bg-red-600 text-white px-4 py-1.5 rounded shadow transition flex items-center gap-2 text-sm">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>
                åœæ­¢æœ—è®€
            </button>

            <label class="cursor-pointer bg-blue-600 hover:bg-blue-700 text-white px-4 py-1.5 rounded shadow transition text-sm font-medium flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/></svg>
                é–‹å•Ÿ PDF
                <input type="file" id="pdfUpload" accept="application/pdf" class="hidden" />
            </label>
        </div>
    </header>

    <!-- ä¸»è¦å…§å®¹å€ -->
    <main class="flex-1 overflow-y-auto relative text-center py-8" id="mainContainer">
        <div id="pdfViewer" class="inline-block text-left">
            <!-- åˆå§‹ç•«é¢ -->
            <div class="mt-20 text-gray-400 text-center flex flex-col items-center">
                <div class="text-6xl mb-4 opacity-50">ğŸ‘†</div>
                <p class="text-xl">è«‹ä¸Šå‚³è€ƒå· PDF</p>
                <p class="text-sm mt-2 opacity-75">é‡åˆ°ä»»ä½•ç©ºç™½æˆ–æ›è¡Œï¼Œç³»çµ±çš†æœƒå¼·åˆ¶åœé “ä¸€ç§’</p>
            </div>
        </div>
    </main>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

        const upload = document.getElementById("pdfUpload");
        const pdfViewer = document.getElementById("pdfViewer");
        const stopBtn = document.getElementById("stopBtn");
        const statusMsg = document.getElementById("statusMsg");
        
        let currentUtterance = null;
        let globalSpanMap = [];
        let fullDocumentText = "";
        let parsedQuestions = [];
        let speakingTimeout = null; 
        
        // é—œéµè®Šæ•¸ï¼šç”¨æ–¼è¿½è¹¤ç•¶å‰æœ‰æ•ˆçš„æ’­æ”¾åºåˆ— ID
        let currentSequenceId = 0;

        stopBtn.addEventListener("click", stopSpeaking);

        upload.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Reset
            pdfViewer.innerHTML = "";
            globalSpanMap = [];
            fullDocumentText = "";
            parsedQuestions = [];
            stopSpeaking();
            showLoading(true, "æ­£åœ¨è§£ææª”æ¡ˆ...");

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    showLoading(true, `æ­£åœ¨è™•ç†ç¬¬ ${i} / ${pdfDoc.numPages} é ...`);
                    const page = await pdfDoc.getPage(i);
                    const textContent = await page.getTextContent();
                    await renderPageAndMapText(page, textContent, i);
                }

                // é–‹å§‹è§£æé¡Œç›®
                parseQuestionsFromFullText(fullDocumentText);
                
                if (parsedQuestions.length === 0) {
                    showError("æ‰¾ä¸åˆ°é¡Œç›®ã€‚è«‹ç¢ºèªæ ¼å¼ç‚ºã€Œæ•¸å­—.ã€æˆ–ã€Œæ•¸å­—ã€ã€é–‹é ­ã€‚");
                } else {
                    showLoading(false);
                    statusMsg.innerHTML = `<span class="text-green-400">âœ“ æº–å‚™å®Œæˆï¼Œå…±è§£æå‡º ${parsedQuestions.length} é¡Œ</span>`;
                    statusMsg.classList.remove("hidden");
                    setTimeout(() => statusMsg.classList.add("hidden"), 3000);
                    console.log("Parsed Questions:", parsedQuestions);
                }

            } catch (err) {
                console.error(err);
                showError("éŒ¯èª¤: " + err.message);
            }
        });

        async function renderPageAndMapText(page, textContent, pageNum) {
            const scale = 1.5;
            const viewport = page.getViewport({ scale: scale });

            const pageWrapper = document.createElement("div");
            pageWrapper.className = "pdf-page-wrapper";
            pageWrapper.style.width = `${viewport.width}px`;
            pageWrapper.style.height = `${viewport.height}px`;

            const canvas = document.createElement("canvas");
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.style.width = "100%";
            canvas.style.height = "100%";
            
            const textLayerDiv = document.createElement("div");
            textLayerDiv.className = "textLayer";
            textLayerDiv.style.width = `${viewport.width}px`;
            textLayerDiv.style.height = `${viewport.height}px`;
            textLayerDiv.style.setProperty("--scale-factor", scale);

            pageWrapper.appendChild(canvas);
            pageWrapper.appendChild(textLayerDiv);
            pdfViewer.appendChild(pageWrapper);

            await page.render({ canvasContext: context, viewport: viewport }).promise;

            await pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport: viewport,
                textDivs: []
            }).promise;

            const spanElements = textLayerDiv.querySelectorAll("span");
            spanElements.forEach((span) => {
                const text = span.textContent;
                const startIndex = fullDocumentText.length;
                fullDocumentText += text;
                const endIndex = fullDocumentText.length;

                globalSpanMap.push({
                    text: text,
                    startIndex: startIndex,
                    endIndex: endIndex,
                    element: span
                });
            });
            fullDocumentText += "\n"; 
        }

        function parseQuestionsFromFullText(text) {
            const regexStart = /(\d+[\.ã€ï¼])/g;
            const matches = [...text.matchAll(regexStart)];
            
            for (let i = 0; i < matches.length; i++) {
                const currentMatch = matches[i];
                const startIdx = currentMatch.index;
                const nextMatch = matches[i + 1];
                let limitIdx = text.length; 
                
                if (nextMatch) {
                    limitIdx = nextMatch.index;
                }

                parsedQuestions.push({
                    text: text.slice(startIdx, limitIdx),
                    startIndex: startIdx,
                    endIndex: limitIdx
                });
            }
        }

        document.addEventListener("click", (e) => {
            if (e.target.tagName === 'SPAN' && e.target.closest('.textLayer')) {
                handleSpanClick(e.target);
            }
        });

        function handleSpanClick(clickedSpan) {
            const spanData = globalSpanMap.find(item => item.element === clickedSpan);
            if (!spanData) return;

            const matchedQuestion = parsedQuestions.find(q => 
                spanData.startIndex >= q.startIndex && 
                spanData.startIndex < q.endIndex
            );

            if (matchedQuestion) {
                console.log("æœ—è®€é¡Œç›®ç¯„åœ:", matchedQuestion.text);
                
                let fullText = matchedQuestion.text.trim();
                let questionNumberText = "";
                let contentText = fullText;

                // 1. åˆ†é›¢é¡Œè™Ÿ (ä¾‹å¦‚ "1." -> "ç¬¬ä¸€é¡Œ")
                const numberMatch = fullText.match(/^(\d+)[\.ã€ï¼]/);
                
                if (numberMatch) {
                    const num = numberMatch[1];
                    questionNumberText = `ç¬¬${num}é¡Œï¼Œ`;
                    contentText = fullText.substring(numberMatch[0].length);
                }

                // 2. å…§å®¹ä¸­çš„é¸é …è™•ç† (â‘  -> \nä¸€)
                // é€™è£¡åœ¨æ•¸å­—å‰åŠ ä¸Š \nï¼Œåˆ©ç”¨ split é‚è¼¯å°‡å…¶åˆ‡åˆ†ç‚ºæ–°æ®µè½
                // é€™æ¨£å‰ä¸€æ®µçµæŸå¾Œå°±æœƒç”¢ç”Ÿ 1ç§’ çš„ postDelayï¼Œé”æˆã€Œå”¸æ•¸å­—å‰åœé “ã€çš„æ•ˆæœ
                contentText = contentText.replace(/â‘ |â‘´|\(1\)|ï¼ˆ1ï¼‰/g, `\nä¸€`);
                contentText = contentText.replace(/â‘¡|â‘µ|\(2\)|ï¼ˆ2ï¼‰/g, `\näºŒ`);
                contentText = contentText.replace(/â‘¢|â‘¶|\(3\)|ï¼ˆ3ï¼‰/g, `\nä¸‰`);
                contentText = contentText.replace(/â‘£|â‘·|\(4\)|ï¼ˆ4ï¼‰/g, `\nå››`);

                // 3. å»ºç«‹æ’­æ”¾åºåˆ—
                const speechQueue = [];
                
                // (A) å¦‚æœæœ‰æŠ“åˆ°é¡Œè™Ÿï¼ŒåŠ å…¥åºåˆ—
                if (questionNumberText) {
                    speechQueue.push({ text: questionNumberText, rate: 0.6, postDelay: 500 });
                }
                
                // (B) å¼·åˆ¶æ ¹æ“šã€Œä»»ä½•ç©ºç™½ã€æˆ–ã€Œæ›è¡Œã€åˆ‡å‰²
                const segments = contentText.split(/[\s\n\u3000]+/);
                
                segments.forEach(seg => {
                    const trimmedSeg = seg.trim();
                    if (trimmedSeg) {
                        speechQueue.push({ 
                            text: trimmedSeg, 
                            rate: 1.0,
                            postDelay: 1000 // æ¯ä¸€æ®µçµæŸå¼·åˆ¶åœé “1ç§’
                        });
                    }
                });

                // åŸ·è¡Œåºåˆ—æ’­æ”¾
                speakSequence(speechQueue);

                // é«˜äº®æ•´é¡Œ
                highlightRange(matchedQuestion.startIndex, matchedQuestion.endIndex);
            } else {
                // å¦‚æœé»æ“Šçš„åœ°æ–¹ä¸åœ¨è§£æçš„é¡Œç›®ç¯„åœå…§
                speakSequence([{ text: clickedSpan.textContent, rate: 1.0 }]);
                
                clickedSpan.classList.add("reading-highlight");
                setTimeout(() => clickedSpan.classList.remove("reading-highlight"), 500);
            }
        }

        function highlightRange(qStart, qEnd) {
            document.querySelectorAll(".reading-highlight").forEach(el => el.classList.remove("reading-highlight"));
            globalSpanMap.forEach(item => {
                const intersectionStart = Math.max(item.startIndex, qStart);
                const intersectionEnd = Math.min(item.endIndex, qEnd);
                if (intersectionStart < intersectionEnd) {
                    item.element.classList.add("reading-highlight");
                }
            });
        }

        // åºåˆ—æ’­æ”¾ (æ”¯æ´ postDelay åœé “ + Sequence ID é˜²è¡çª)
        function speakSequence(items) {
            stopSpeaking(); // é€™æœƒè®“ currentSequenceId éå¢
            
            if (!items || items.length === 0) return;

            const mySequenceId = currentSequenceId;
            let currentIndex = 0;

            function playNext() {
                if (mySequenceId !== currentSequenceId) return;

                if (currentIndex >= items.length) {
                    checkIfSpeakingStopped();
                    return;
                }

                const item = items[currentIndex];
                
                if (!item.text || !item.text.trim()) {
                    currentIndex++;
                    playNext();
                    return;
                }

                const u = new SpeechSynthesisUtterance(item.text);
                currentUtterance = u; 
                
                u.lang = "zh-TW";
                u.rate = item.rate || 1.0; 
                
                const voices = speechSynthesis.getVoices();
                const zhVoice = voices.find(v => v.lang === "zh-TW" || v.lang === "zh-HK" || v.lang.includes("zh"));
                if (zhVoice) u.voice = zhVoice;

                u.onstart = () => {
                    if (mySequenceId === currentSequenceId) {
                        stopBtn.classList.remove("hidden");
                    }
                };
                
                u.onend = () => {
                    if (mySequenceId !== currentSequenceId) return; 

                    if (item.postDelay) {
                        speakingTimeout = setTimeout(() => {
                            if (mySequenceId !== currentSequenceId) return; 
                            currentIndex++;
                            playNext();
                        }, item.postDelay);
                    } else {
                        currentIndex++;
                        playNext();
                    }
                };

                u.onerror = (e) => {
                    if (e.error === 'interrupted' || e.error === 'canceled') return;
                    console.warn("Speech skipped due to error:", e.error);
                    if (mySequenceId === currentSequenceId) {
                        currentIndex++;
                        playNext();
                    }
                };

                speechSynthesis.speak(u);
            }

            playNext();
        }

        function stopSpeaking() {
            currentSequenceId++;
            speechSynthesis.cancel();
            currentUtterance = null;
            if (speakingTimeout) {
                clearTimeout(speakingTimeout);
                speakingTimeout = null;
            }
            stopBtn.classList.add("hidden");
            document.querySelectorAll(".reading-highlight").forEach(el => el.classList.remove("reading-highlight"));
        }

        function checkIfSpeakingStopped() {
            if (!speechSynthesis.speaking) stopBtn.classList.add("hidden");
        }

        function showLoading(show, text = "") {
            statusMsg.classList.remove("hidden", "text-red-400");
            if (show) {
                statusMsg.innerHTML = `<div class="loader"></div> <span>${text}</span>`;
                statusMsg.classList.remove("hidden");
            } else {
                statusMsg.classList.add("hidden");
            }
        }

        function showError(msg) {
            statusMsg.innerHTML = `âš ï¸ ${msg}`;
            statusMsg.classList.remove("hidden");
            statusMsg.classList.add("text-red-400");
        }

        if (typeof speechSynthesis !== 'undefined') {
            speechSynthesis.onvoiceschanged = () => {};
        }
    </script>
</body>
</html>