<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>數學大冒險：減法下樓梯</title>
    <!-- 引入像素字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive; /* 8-bit 字體 */
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #fff;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #5c94fc; /* 天空藍 */
            border: 8px solid #f8f9fa;
            outline: 8px solid #000;
            border-radius: 4px;
            box-shadow: 0 0 0 16px #5c94fc, 0 20px 50px rgba(0,0,0,0.5);
            padding: 20px;
            width: 100%;
            max-width: 600px; /* 加寬以容納大字體 */
            box-sizing: border-box;
            position: relative;
            image-rendering: pixelated;
            min-height: 750px;
        }

        /* 標題樣式 - 放大 */
        h1 {
            color: #ffce00;
            text-shadow: 6px 6px #d33818;
            margin-bottom: 30px;
            font-size: 2.4rem; /* 放大一倍 */
            text-align: center;
            line-height: 1.5;
        }

        /* 畫布樣式 */
        #gameCanvas {
            border: 4px solid #000;
            background-color: #5c94fc;
            image-rendering: pixelated;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
        }

        /* 介面面板 */
        .panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        /* 隱藏未激活的面板 */
        .hidden {
            display: none !important;
        }

        /* 主選單樣式 */
        .menu-options {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 4px solid #fff;
            border-radius: 8px;
            width: 95%;
            margin-bottom: 20px;
        }

        /* 選單文字放大 */
        .menu-options p {
            font-size: 1.5rem; /* 放大 */
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 25px; /* 間距加大 */
            text-align: left;
            margin-bottom: 30px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 1.4rem; /* 放大一倍 (原本0.8左右) */
            line-height: 1.5;
        }

        .checkbox-item input {
            appearance: none;
            width: 40px; /* 放大 */
            height: 40px; /* 放大 */
            border: 4px solid #fff;
            background: #000;
            margin-right: 20px;
            position: relative;
            cursor: pointer;
            flex-shrink: 0;
        }

        .checkbox-item input:checked::after {
            content: '✓';
            position: absolute;
            color: #00ff00;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px; /* 放大 */
        }

        /* 分數面板 */
        .score-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 0;
            font-size: 0.8rem;
            color: #fff;
            text-shadow: 2px 2px #000;
            margin-bottom: 10px;
        }

        /* 按鈕樣式 (NES 風格) */
        button {
            background-color: #e60012; /* 任天堂紅 */
            color: white;
            padding: 15px 20px;
            border: 4px solid #8b0000; /* 深紅邊框 */
            box-shadow: inset 4px 4px 0px rgba(255,255,255,0.3), 4px 4px 0px #000;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            cursor: pointer;
            text-transform: uppercase;
            position: relative;
            top: 0;
            transition: top 0.1s, box-shadow 0.1s;
        }

        /* 主選單確定按鈕放大 */
        #menuConfirmButton {
            font-size: 1.6rem;
            padding: 20px 40px;
        }

        button:hover {
            background-color: #ff1a1a;
        }

        button:active {
            top: 4px;
            box-shadow: inset 4px 4px 0px rgba(0,0,0,0.2), 0px 0px 0px #000;
        }

        button:disabled {
            background-color: #666;
            border-color: #444;
            cursor: not-allowed;
            color: #aaa;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }

        /* 遊戲內的按鈕樣式 */
        .game-btn {
            font-size: 1rem;
            padding: 15px 25px;
            min-width: 120px;
        }

        #gameStartButton {
            background-color: #00aa00; /* 綠色 */
            border-color: #006600;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #backButton {
            background-color: #fca044; /* 橘色 */
            border-color: #a0522d;
        }

        /* 觸控控制 */
        .mobile-controls {
            display: none;
            justify-content: space-between;
            width: 100%;
            margin-top: 20px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .d-pad-btn {
            width: 60px;
            height: 60px;
            background: #333;
            border: 4px solid #000;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: #ccc;
            box-shadow: 0 4px 0 #000;
        }
        
        .d-pad-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #000;
            background: #555;
        }

        @media (max-width: 1024px) { 
            .mobile-controls { display: flex; }
        }

        /* 彈窗樣式 */
        .message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 20;
            border-radius: 4px;
        }
        
        .message-box {
            background: #000;
            padding: 30px;
            border: 4px solid #fff;
            text-align: center;
            max-width: 90%;
            color: #fff;
        }

        .message-box h2 {
            color: #e60012;
            margin-top: 0;
            font-size: 1.5rem;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .message-box p {
            font-size: 1rem;
            line-height: 1.8;
            margin-bottom: 30px;
            color: #ddd;
        }

        /* 測驗區樣式 */
        #quizInput {
            width: 100%;
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            margin: 15px 0;
            border: 4px solid #fff;
            background: #000;
            color: #00ff00;
            text-align: center;
            box-sizing: border-box;
        }
        
        #quizInput::placeholder {
            color: #555;
            font-size: 1rem;
        }

        .quiz-hint {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 10px;
        }

        .quiz-error {
            color: #ff5555;
            font-size: 0.8rem;
            display: none;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>數學大冒險<br>減法下樓梯</h1>
        
        <!-- === 主選單畫面 === -->
        <div id="menuScreen" class="panel">
            <div class="menu-options">
                <p style="text-align: center; margin-bottom: 30px; color: #00ff00;">選擇題型</p>
                <div class="checkbox-group">
                    <label class="checkbox-item">
                        <input type="checkbox" id="opt1" checked>
                        一位數 - 一位數<br>(8 - 3)
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="opt2" checked>
                        二位數 - 一位數<br>(25 - 4)
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="opt3">
                        二位數 - 二位數<br>(45 - 23)
                    </label>
                    <hr style="border: 2px dashed #fff; width: 100%; margin: 15px 0;">
                    <label class="checkbox-item">
                        <input type="checkbox" id="optBorrow">
                        必須包含退位<br>(挑戰模式)
                    </label>
                </div>
                <div style="text-align: center;">
                    <button id="menuConfirmButton">確定</button>
                </div>
            </div>
            <div style="margin-top: 20px; font-size: 0.8rem; color: #ccc;">
                © 2025 PIXEL EDU GAMES
            </div>
        </div>

        <!-- === 遊戲畫面 === -->
        <div id="gameScreen" class="panel hidden">
            
            <div class="score-panel">
                <span>分數 <span id="scoreDisplay" style="color:#ffce00">0000</span></span>
                <span>最高分 <span id="highScoreDisplay" style="color:#ffce00">0000</span></span>
            </div>
            
            <canvas id="gameCanvas" width="380" height="500"></canvas>
            
            <div class="controls">
                <div class="mobile-controls">
                    <div class="d-pad-btn" id="leftButton">◀</div>
                    <div class="d-pad-btn" id="rightButton">▶</div>
                </div>
                <div class="action-buttons">
                    <button id="gameStartButton" class="game-btn">開始</button>
                    <button id="pauseButton" class="game-btn" style="display: none;">暫停</button>
                    <button id="backButton" class="game-btn">主選單</button>
                    <!-- 隱藏的上傳按鈕，保持功能但介面簡潔 -->
                    <input type="file" id="imageInput" accept="image/*" style="display: none;">
                    <button id="uploadButton" class="game-btn">換角色圖</button>
                </div>
            </div>
        </div>

        <!-- 訊息彈窗 (遊戲結束) -->
        <div class="message-overlay" id="messageOverlay">
            <div class="message-box">
                <h2 id="messageTitle">遊戲結束</h2>
                <p id="messageText">得分: 100</p>
                <button id="closeMessageButton" style="font-size: 1.2rem; padding: 15px 30px;">確定</button>
            </div>
        </div>

        <!-- 答題彈窗 -->
        <div class="message-overlay" id="quizOverlay">
            <div class="message-box">
                <h2 style="color: #ffce00; text-shadow: 2px 2px #d33818;">問題來了！</h2>
                <div style="font-size: 2rem; margin: 20px 0; letter-spacing: 2px;" id="quizQuestion">
                    25 - 5 = ?
                </div>
                <input type="number" pattern="[0-9]*" inputmode="numeric" id="quizInput" placeholder="?" autocomplete="off">
                <div class="quiz-error" id="quizError">答錯了！再試一次。</div>
                <p class="quiz-hint">請輸入計算結果</p>
                <button id="submitQuizButton" style="font-size: 1.2rem; padding: 15px 30px;">送出</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Init ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'mario-math-stairs';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId = null, isAuthReady = false;
        const HIGH_SCORE_DOC_PATH = `/artifacts/${appId}/public/data/highScores/global_mario_sub_v2`;

        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Screens
        const menuScreen = document.getElementById('menuScreen');
        const gameScreen = document.getElementById('gameScreen');
        
        // UI Elements
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const menuConfirmButton = document.getElementById('menuConfirmButton'); 
        
        const gameStartButton = document.getElementById('gameStartButton');
        const backButton = document.getElementById('backButton');
        const pauseButton = document.getElementById('pauseButton');
        const uploadButton = document.getElementById('uploadButton');
        const imageInput = document.getElementById('imageInput');
        
        // Overlays
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const closeMessageButton = document.getElementById('closeMessageButton');
        const quizOverlay = document.getElementById('quizOverlay');
        const quizQuestion = document.getElementById('quizQuestion');
        const quizInput = document.getElementById('quizInput');
        const quizError = document.getElementById('quizError');
        const submitQuizButton = document.getElementById('submitQuizButton');

        // Checkboxes
        const opt1 = document.getElementById('opt1'); 
        const opt2 = document.getElementById('opt2'); 
        const opt3 = document.getElementById('opt3'); 
        const optBorrow = document.getElementById('optBorrow'); 

        // Constants - 速度調整
        const PLAYER_SIZE = 30; 
        const GRAVITY = 0.8;
        const OBSTACLE_HEIGHT = 24; 
        const OBSTACLE_ROW_DISTANCE = 120;
        
        const SPEED_START = 1.0; 
        const SPEED_MAX = 7.0; 
        
        // 角色移動速度固定為 2.5，絕對不變
        const PLAYER_SPEED = 2.5; 

        // Assets
        const playerImage = new Image();
        let playerImageLoaded = false;
        let brickPattern = null;
        let qBlockPattern = null;

        // Game State
        let gameState = {
            isRunning: false,
            isPaused: false,
            isQuizActive: false,
            gameOver: false,
            score: 0,
            floorsPassed: 0,
            correctStreak: 0, // 追蹤答對題數
            highScore: 0,
            player: { x: 0, y: 0, dx: 0, dy: 0, isJumping: false, width: PLAYER_SIZE, height: PLAYER_SIZE },
            obstacles: [],
            obstacleSpeed: SPEED_START,
            countedRows: new Set(),
            remainingQuestions: [],
            currentQuizNode: null
        };

        // --- Firebase ---
        async function initializeFirebase() {
            try {
                if (firebaseConfig) {
                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
                    else await signInAnonymously(auth);

                    onAuthStateChanged(auth, (user) => {
                        userId = user ? user.uid : 'anon_' + crypto.randomUUID();
                        isAuthReady = true;
                        setupHighScoreListener();
                    });
                } else isAuthReady = true;
            } catch (e) { console.error(e); isAuthReady = true; }
        }

        function setupHighScoreListener() {
            if (!db || !isAuthReady) return;
            onSnapshot(doc(db, HIGH_SCORE_DOC_PATH), (snap) => {
                if (snap.exists()) {
                    gameState.highScore = snap.data().score || 0;
                    highScoreDisplay.textContent = gameState.highScore.toString().padStart(4, '0');
                }
            });
        }

        async function updateHighScore() {
            if (!db || !isAuthReady || !userId || gameState.score <= gameState.highScore) return;
            await setDoc(doc(db, HIGH_SCORE_DOC_PATH), { 
                score: gameState.score, setBy: userId, timestamp: new Date().toISOString()
            }, { merge: true });
        }

        // --- Question Generation Logic ---
        function generateQuestions() {
            let pool = [];
            const useOpt1 = opt1.checked;
            const useOpt2 = opt2.checked;
            const useOpt3 = opt3.checked;
            const forceBorrow = optBorrow.checked;

            if (!useOpt1 && !useOpt2 && !useOpt3) {
                // Default fallback if nothing selected
                pool.push({ a: 10, b: 5, ans: 5 });
                return pool;
            }

            // Helper to add range
            const addRange = (minA, maxA, minB, maxB) => {
                for (let a = minA; a <= maxA; a++) {
                    for (let b = minB; b <= maxB; b++) {
                        if (a >= b) {
                            const unitA = a % 10;
                            const unitB = b % 10;
                            const needsBorrow = unitA < unitB;

                            if (forceBorrow) {
                                if (needsBorrow) pool.push({a, b, ans: a-b});
                            } else {
                                if (!needsBorrow) pool.push({a, b, ans: a-b});
                            }
                        }
                    }
                }
            };

            if (useOpt1) addRange(1, 9, 1, 9);
            if (useOpt2) addRange(10, 99, 1, 9);
            if (useOpt3) addRange(10, 99, 10, 99);

            if (pool.length === 0) {
                return [{a: 10, b: 1, ans: 9}, {a: 20, b: 5, ans: 15}];
            }

            // Shuffle
            for (let i = pool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pool[i], pool[j]] = [pool[j], pool[i]];
            }

            // Return up to 30 questions to keep memory light
            return pool.slice(0, 30);
        }

        // --- Patterns (Pixel Art Generation) ---
        function createPixelPatterns() {
            // 1. Brick Pattern (Mario Style - Brown/Orange)
            const bCanvas = document.createElement('canvas');
            bCanvas.width = 16; bCanvas.height = 16;
            const bCtx = bCanvas.getContext('2d');
            // Base
            bCtx.fillStyle = '#b85c38'; // Brick brown
            bCtx.fillRect(0,0,16,16);
            // Highlights/Shadows
            bCtx.fillStyle = '#000'; // Black lines
            bCtx.fillRect(0,0,16,1); // Top line
            bCtx.fillRect(0,8,16,1); // Mid line
            bCtx.fillRect(8,0,1,8);  // Vert 1
            bCtx.fillRect(0,8,1,8);  // Vert 2
            bCtx.fillStyle = '#e09060'; // Highlight
            bCtx.fillRect(1,1,7,1); bCtx.fillRect(9,1,6,1);
            bCtx.fillRect(1,9,14,1);
            brickPattern = ctx.createPattern(bCanvas, 'repeat');

            // 2. Question Block (Yellow)
            const qCanvas = document.createElement('canvas');
            qCanvas.width = 16; qCanvas.height = 16;
            const qCtx = qCanvas.getContext('2d');
            qCtx.fillStyle = '#ffce00'; // Gold
            qCtx.fillRect(0,0,16,16);
            qCtx.fillStyle = '#d33818'; // Shadow corner
            qCtx.fillRect(1,14,14,1); qCtx.fillRect(14,1,1,14);
            qCtx.fillStyle = '#ffe780'; // Highlight
            qCtx.fillRect(1,1,14,1); qCtx.fillRect(1,1,1,14);
            // Bolts
            qCtx.fillStyle = '#000';
            qCtx.fillRect(1,1,1,1); qCtx.fillRect(14,1,1,1);
            qCtx.fillRect(1,14,1,1); qCtx.fillRect(14,14,1,1);
            // Question Mark
            qCtx.fillStyle = '#b85c38'; 
            qCtx.fillRect(6,3,5,2); qCtx.fillRect(10,5,2,3);
            qCtx.fillRect(7,7,2,2); qCtx.fillRect(7,11,2,2);
            qBlockPattern = qCanvas; // Store canvas directly to draw image
        }

        // --- Game Logic ---

        // 重新計算障礙物速度 - 僅兩階段加速
        function calculateObstacleSpeed() {
            // 每答對3題進入下一個速度階段
            const streak = gameState.correctStreak;
            
            let multiplier = 1.0; // 預設 1.0 倍
            
            if (streak >= 6) {
                // 答對 6 題以上：第二階段加速 (1.2倍)
                multiplier = 1.2;
            } else if (streak >= 3) {
                // 答對 3~5 題：第一階段加速 (1.1倍)
                multiplier = 1.1;
            } else {
                // 答對 0~2 題：維持原速
                multiplier = 1.0;
            }
            
            gameState.obstacleSpeed = SPEED_START * multiplier;
            
            console.log(`Streak: ${streak}, Multiplier: ${multiplier}, Speed: ${gameState.obstacleSpeed}`);
        }

        // 第一階段：從主選單「確定」後，只切換畫面並初始化場景，不開始跑迴圈
        function setupGameScene() {
            // Initialize math pool
            const pool = generateQuestions();
            if (pool.length < 1) {
                alert("找不到符合條件的題目！請調整選項。");
                return;
            }
            gameState.remainingQuestions = pool;
            
            // Switch Screens
            menuScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            // UI State for "Ready"
            gameStartButton.style.display = 'inline-block';
            pauseButton.style.display = 'none';

            // Reset Logic but DON'T start loop
            gameState.isRunning = false; // 等待點擊開始
            gameState.isPaused = false;
            gameState.isQuizActive = false;
            gameState.gameOver = false;
            gameState.score = 0;
            gameState.floorsPassed = 0;
            gameState.correctStreak = 0; // 重置連續答對計數
            gameState.obstacleSpeed = SPEED_START;
            gameState.countedRows = new Set();
            gameState.obstacles = [];
            
            scoreDisplay.textContent = "0000";

            // Init platforms
            for(let i=0; i<7; i++) {
                let y = canvas.height - i * OBSTACLE_ROW_DISTANCE;
                
                // 強制第1個生成(i=1, 從下數來第二層)的平台為安全平台
                // 為了讓玩家可以下去，這個平台必須有缺口
                // 我們創建一個佔據大部分寬度的平台，但在右側留出空隙
                if (i === 1) {
                    const rowId = crypto.randomUUID();
                    // 創建一個從左側開始，寬度為 canvas.width - 100 的平台 (右側留 100px 洞)
                    let obs = {
                        x: 0, 
                        y: y, 
                        width: canvas.width - 100, 
                        height: OBSTACLE_HEIGHT, 
                        rowId: rowId, 
                        hasNode: false, 
                        question: null
                    };
                    gameState.obstacles.push(obs);
                    
                    // 將主角放在畫面中央 (canvas.width/2)，這裡是有地板的 (因為寬度延伸到了右邊界前100px)
                    gameState.player.x = canvas.width/2 - PLAYER_SIZE/2;
                    gameState.player.y = y - PLAYER_SIZE; // 站在平台上
                    gameState.player.dx = 0;
                    gameState.player.dy = 0;
                    gameState.player.isJumping = false; 
                } else {
                    generateObstacleRow(y);
                }
            }

            // Draw initial static frame
            draw();
        }

        // 第二階段：真正的開始遊戲
        function startGamePlay() {
            // Toggle Buttons
            gameStartButton.style.display = 'none';
            pauseButton.style.display = 'inline-block';

            gameState.isRunning = true;
            requestAnimationFrame(gameLoop);
        }

        function returnToMenu() {
            gameState.isRunning = false;
            gameScreen.classList.add('hidden');
            menuScreen.classList.remove('hidden');
            quizOverlay.style.display = 'none';
            messageOverlay.style.display = 'none';
        }

        function generateObstacleRow(y) {
            const rowId = crypto.randomUUID();
            const minW = 40;
            const gapMin = 50; const gapMax = 90;
            
            let platforms = [{x: 0, w: canvas.width}];
            // Create 1 or 2 gaps
            let gaps = Math.random() > 0.6 ? 2 : 1;
            
            for(let i=0; i<gaps; i++) {
                let valid = platforms.filter(p => p.w > minW*2 + gapMin);
                if(valid.length === 0) break;
                let target = valid[Math.floor(Math.random()*valid.length)];
                
                // Remove target
                platforms = platforms.filter(p => p !== target);
                
                let gapW = gapMin + Math.random()*(gapMax-gapMin);
                let maxGapX = target.x + target.w - minW - gapW;
                let minGapX = target.x + minW;
                let gapX = minGapX + Math.random()*(maxGapX - minGapX);
                
                platforms.push({x: target.x, w: gapX - target.x});
                platforms.push({x: gapX + gapW, w: (target.x+target.w) - (gapX+gapW)});
            }

            platforms.forEach(p => {
                let obs = {
                    x: p.x, y: y, width: p.w, height: OBSTACLE_HEIGHT,
                    rowId: rowId, hasNode: false, question: null
                };
                
                // Add Question Block (Chance: 25%)
                if (gameState.remainingQuestions.length > 0 && p.w > 40 && Math.random() < 0.25) {
                    obs.hasNode = true;
                    obs.question = gameState.remainingQuestions[Math.floor(Math.random() * gameState.remainingQuestions.length)];
                    obs.nodeX = obs.x + 20 + Math.random() * (obs.width - 40);
                }
                gameState.obstacles.push(obs);
            });
        }

        function update() {
            if (!gameState.isRunning || gameState.isPaused || gameState.isQuizActive) return;

            // Player Physics
            gameState.player.dy += GRAVITY;
            gameState.player.y += gameState.player.dy;
            gameState.player.x += gameState.player.dx; // dx is strictly PLAYER_SPEED or -PLAYER_SPEED or 0

            // Boundaries
            if (gameState.player.x < 0) gameState.player.x = 0;
            if (gameState.player.x + PLAYER_SIZE > canvas.width) gameState.player.x = canvas.width - PLAYER_SIZE;

            // Platform Collision
            let onGround = false;
            
            // Game Over conditions
            if (gameState.player.y > canvas.height) {
                gameOver();
                return;
            }
            if (gameState.player.y < -PLAYER_SIZE) {
                gameOver();
                return;
            }

            gameState.obstacles.forEach(obs => {
                // Collision Detection
                if (
                    gameState.player.dy >= 0 && // Falling
                    gameState.player.y + PLAYER_SIZE >= obs.y &&
                    gameState.player.y + PLAYER_SIZE <= obs.y + OBSTACLE_HEIGHT + 5 && // Tolerance
                    gameState.player.x + PLAYER_SIZE > obs.x &&
                    gameState.player.x < obs.x + obs.width
                ) {
                    gameState.player.y = obs.y - PLAYER_SIZE;
                    gameState.player.dy = 0;
                    gameState.player.isJumping = false;
                    onGround = true;
                    // Move player with platform (Only vertical stickiness)
                    gameState.player.y -= gameState.obstacleSpeed;
                }

                // Question Block Collision
                if (obs.hasNode) {
                    let bx = obs.nodeX - 12;
                    let by = obs.y - 24; 
                    let bw = 24; let bh = 24;
                    
                    let px = gameState.player.x + PLAYER_SIZE/2;
                    let py = gameState.player.y + PLAYER_SIZE/2;
                    
                    let dist = Math.abs(px - obs.nodeX);
                    if (dist < 20 && Math.abs(py - (obs.y - 12)) < 30) {
                        triggerQuiz(obs);
                    }
                }
            });

            if (!onGround && gameState.player.dy === 0) {
                gameState.player.dy = 1; // Start falling if platform disappeared
            }

            // Move Obstacles UP
            let nextObs = [];
            gameState.obstacles.forEach(obs => {
                obs.y -= gameState.obstacleSpeed;
                if (obs.y + OBSTACLE_HEIGHT > 0) {
                    nextObs.push(obs);
                } else {
                    if (!gameState.countedRows.has(obs.rowId)) {
                        gameState.countedRows.add(obs.rowId);
                        gameState.floorsPassed++;
                        if (gameState.floorsPassed % 5 === 0) {
                            gameState.score += 1;
                            updateScoreUI();
                        }
                    }
                }
            });
            gameState.obstacles = nextObs;

            // Generate new rows
            let lastY = gameState.obstacles.length > 0 
                ? Math.max(...gameState.obstacles.map(o => o.y)) 
                : 0;
            
            if (lastY < canvas.height - OBSTACLE_ROW_DISTANCE) {
                generateObstacleRow(canvas.height);
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#5c94fc'; // Sky Blue
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Clouds
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillRect(50, 100, 60, 20); ctx.fillRect(70, 90, 30, 10);
            ctx.fillRect(250, 300, 80, 20); ctx.fillRect(270, 290, 40, 10);

            // Draw Platforms
            if (brickPattern) {
                gameState.obstacles.forEach(obs => {
                    ctx.save();
                    ctx.translate(0, Math.floor(obs.y)); // Pixel align
                    ctx.fillStyle = brickPattern;
                    ctx.fillRect(obs.x, 0, obs.width, OBSTACLE_HEIGHT);
                    
                    ctx.fillStyle = '#ffce00';
                    ctx.fillRect(obs.x, 0, obs.width, 2);
                    
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obs.x, 0, obs.width, OBSTACLE_HEIGHT);
                    ctx.restore();

                    // Question Block
                    if (obs.hasNode) {
                        let size = 24;
                        ctx.drawImage(qBlockPattern, obs.nodeX - size/2, obs.y - size, size, size);
                    }
                });
            }

            // Draw Player
            if (playerImageLoaded) {
                ctx.drawImage(playerImage, gameState.player.x, gameState.player.y, PLAYER_SIZE, PLAYER_SIZE);
            } else {
                // 通用小朋友像素圖 (預設) - 簡單的笑臉/人型
                const px = gameState.player.x;
                const py = gameState.player.y;
                
                // 身體
                ctx.fillStyle = '#3b82f6'; // 藍色上衣
                ctx.fillRect(px + 5, py + 15, 20, 15);
                
                // 頭部
                ctx.fillStyle = '#fca5a5'; // 皮膚色
                ctx.fillRect(px + 5, py, 20, 15);
                
                // 眼睛
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 10, py + 5, 2, 2);
                ctx.fillRect(px + 18, py + 5, 2, 2);
                
                // 嘴巴
                ctx.fillRect(px + 12, py + 10, 6, 2);

                // 手腳
                ctx.fillStyle = '#3b82f6';
                ctx.fillRect(px, py + 15, 5, 10); // 左手
                ctx.fillRect(px + 25, py + 15, 5, 10); // 右手
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 5, py + 30, 8, 5); // 左腳
                ctx.fillRect(px + 17, py + 30, 8, 5); // 右腳
            }
        }

        function gameLoop() {
            if(gameState.isRunning) {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        function triggerQuiz(obs) {
            gameState.isPaused = true;
            gameState.isQuizActive = true;
            gameState.currentQuizNode = obs;
            
            quizQuestion.textContent = `${obs.question.a} - ${obs.question.b} = ?`;
            quizInput.value = '';
            quizError.style.display = 'none';
            quizOverlay.style.display = 'flex';
            setTimeout(() => quizInput.focus(), 100);
        }

        function checkAnswer() {
            const val = parseInt(quizInput.value);
            if (isNaN(val)) return;

            if (val === gameState.currentQuizNode.question.ans) {
                // Correct
                gameState.currentQuizNode.hasNode = false;
                
                // Add Score
                gameState.score += 5;
                updateScoreUI();

                // Increment streak
                gameState.correctStreak++;
                
                // Recalculate Speed based on streak logic
                calculateObstacleSpeed();
                
                // Resume
                quizOverlay.style.display = 'none';
                gameState.isQuizActive = false;
                gameState.isPaused = false;
                requestAnimationFrame(gameLoop);
            } else {
                quizError.style.display = 'block';
                quizInput.value = '';
                quizInput.focus();
            }
        }

        function updateScoreUI() {
            scoreDisplay.textContent = gameState.score.toString().padStart(4, '0');
        }

        function gameOver() {
            gameState.isRunning = false;
            gameState.gameOver = true;
            updateHighScore();
            messageTitle.textContent = "遊戲結束";
            messageText.textContent = `得分: ${gameState.score}`;
            messageOverlay.style.display = 'flex';
        }

        // --- Event Listeners ---
        menuConfirmButton.addEventListener('click', setupGameScene); 
        gameStartButton.addEventListener('click', startGamePlay); // 新增的遊戲內開始按鈕
        
        backButton.addEventListener('click', returnToMenu);
        
        pauseButton.addEventListener('click', () => {
            if (!gameState.isRunning || gameState.gameOver) return;
            gameState.isPaused = !gameState.isPaused;
            if(!gameState.isPaused) requestAnimationFrame(gameLoop);
            else {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '20px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText("暫停中", canvas.width/2, canvas.height/2);
            }
        });

        closeMessageButton.addEventListener('click', () => {
            messageOverlay.style.display = 'none';
            returnToMenu();
        });

        submitQuizButton.addEventListener('click', checkAnswer);
        quizInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') checkAnswer(); });

        // Inputs
        document.addEventListener('keydown', (e) => {
            if (!gameState.isRunning || gameState.isPaused) return;
            // Strict Constant Speed
            if (e.key === 'ArrowLeft') gameState.player.dx = -PLAYER_SPEED;
            if (e.key === 'ArrowRight') gameState.player.dx = PLAYER_SPEED;
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') gameState.player.dx = 0;
        });

        // Touch
        const lBtn = document.getElementById('leftButton');
        const rBtn = document.getElementById('rightButton');
        lBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.player.dx = -PLAYER_SPEED; });
        lBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.player.dx = 0; });
        lBtn.addEventListener('mousedown', () => gameState.player.dx = -PLAYER_SPEED);
        lBtn.addEventListener('mouseup', () => gameState.player.dx = 0);
        
        rBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.player.dx = PLAYER_SPEED; });
        rBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.player.dx = 0; });
        rBtn.addEventListener('mousedown', () => gameState.player.dx = PLAYER_SPEED);
        rBtn.addEventListener('mouseup', () => gameState.player.dx = 0);

        // Upload
        uploadButton.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', (e) => {
            const f = e.target.files[0];
            if(f) {
                const r = new FileReader();
                r.onload = (ev) => { playerImage.src = ev.target.result; playerImage.onload = () => playerImageLoaded = true; };
                r.readAsDataURL(f);
            }
        });

        window.onload = () => {
            createPixelPatterns();
            initializeFirebase();
        };

    </script>
</body>
</html>