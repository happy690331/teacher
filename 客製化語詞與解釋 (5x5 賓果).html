<!doctype html>
<html lang="zh-TW">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è‡ªè¨‚èªè©è³“æœ Canvas ç‰ˆ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;600;700&display=swap');
        
        /* åŸºæœ¬å­—é«”è¨­å®š */
        body {
            font-family: 'Noto Sans TC', sans-serif;
            box-sizing: border-box;
        }
        
        /* è®“ Canvas å……æ»¿å®¹å™¨ä¸¦ä¿æŒéŸ¿æ‡‰å¼ */
        #bingoCanvas {
            display: block;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            touch-action: manipulation; /* æé«˜è§¸æ§åæ‡‰é€Ÿåº¦ */
            cursor: pointer;
        }

        /* è¼¸å…¥ä»‹é¢ Grid ä½ˆå±€ */
        .input-grid {
            /* èª¿æ•´ç‚ºå–®æ¬„ä½ˆå±€ä»¥å®¹ç´ Textarea */
            grid-template-columns: 1fr; 
        }
        
        /* è¨Šæ¯æ¡†æ¨£å¼ */
        #messageBox {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        #messageBox.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        /* å½©å¸¶æ•ˆæœå®¹å™¨ */
        #confettiContainer {
            position: fixed; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 50; 
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        /* æ³¨å…¥ Canvas Confetti Keyframes */
        @keyframes confetti-fall {
            0% { transform: translate(var(--startX), -10vh) rotate(0deg); opacity: 1; }
            100% { transform: translate(var(--endX), 110vh) rotate(720deg); opacity: 0; }
        }
    </style>
 </head>
 <body class="bg-gradient-to-br from-blue-50 via-purple-50 to-pink-50 min-h-screen p-4 md:p-8">
    
    <!-- 3ç§’å½©å¸¶å‹•ç•«å®¹å™¨ (ç”¨æ–¼è³“æœå‹åˆ©) -->
    <div id="confettiContainer"></div>
    
    <!-- è¨Šæ¯æ¡† -->
    <div id="messageBox" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50"></div>
    
    <!-- Main container -->
    <div class="max-w-6xl mx-auto flex flex-col gap-6"> 
        
        <!-- éšæ®µä¸€ï¼šèªè©è¼¸å…¥ä»‹é¢ (DOM) -->
        <div id="inputArea" class="flex-grow max-w-xl mx-auto w-full">
            <div class="text-center mb-6 p-4 bg-white/80 rounded-xl shadow-lg">
                <h1 class="text-3xl font-bold text-gray-800 mb-2">ğŸ“ è‡ªè¨‚èªè©èˆ‡è§£é‡‹ (5x5 è³“æœ)</h1>
                <p class="text-gray-600 mt-2 font-semibold">è«‹è¼¸å…¥æ‚¨çš„èª²æœ¬/å­—å…¸å…§å®¹ï¼Œæ¯çµ„è³‡æ–™ä½”ä¸€è¡Œã€‚</p>
                <p class="text-gray-600 mt-1">æ ¼å¼ç¯„ä¾‹ï¼š<code class="bg-yellow-200 p-1 rounded font-mono">ç·¨è™Ÿ èªè©ï¼šè§£é‡‹å…§å®¹ ä¾‹å¥...</code>ï¼ˆç¨‹å¼æœƒè‡ªå‹•æŠ“å–**èªè©**å’Œ**è§£é‡‹**ï¼Œä¸¦å¿½ç•¥ç·¨è™ŸåŠã€Œä¾‹å¥ã€ä¹‹å¾Œçš„å…§å®¹ï¼‰</p>
                <div class="mt-4 text-sm text-red-500 font-medium" id="inputError"></div>
            </div>
            
            <div class="input-grid">
                <!-- èª¿æ•´ç‚ºå–®ä¸€ Textarea -->
                <textarea id="vocabInput" rows="15" class="w-full border border-gray-300 rounded-lg shadow-md p-4 text-base focus:ring-indigo-500 focus:border-indigo-500" placeholder="è«‹åœ¨æ­¤è¼¸å…¥æ‚¨çš„èªè©èˆ‡è§£é‡‹ï¼Œæ¯è¡Œä¸€çµ„ï¼š&#10;ä¾‹ï¼š\nâ’ˆ è€¶èª•ç¯€ï¼šç´€å¿µè€¶ç©Œèª•ç”Ÿçš„ç¯€æ—¥ã€‚ä¾‹å¥..."></textarea>
            </div>
            
            <div class="flex justify-center mt-6 gap-4">
                <button id="clearInputButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 rounded-lg shadow-xl transition duration-150 transform hover:scale-105">
                    ä¸€éµæ¸…ç©º
                </button>
                <button id="startGameButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg shadow-xl transition duration-150 transform hover:scale-105">
                    å•Ÿå‹•è³“æœéŠæˆ²ï¼
                </button>
            </div>
        </div>

        <!-- éšæ®µäºŒï¼šè³“æœéŠæˆ²ä»‹é¢ (Canvas) -->
        <div id="gameArea" class="flex-grow hidden">
            <!-- æ¨™é¡Œ -->
            <div class="text-center mb-6">
                <h1 id="gameTitle" class="text-4xl font-bold text-gray-800 mb-2">âœ¨ èªè©è³“æœæŒ‘æˆ° âœ¨</h1>
            </div>
            
            <div class="flex justify-center mb-6 gap-4">
                <button id="resetButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-xl transition duration-150 transform hover:scale-105">
                    é‡æ–°é–‹å§‹ (ä¸è®Šæ›´èªè©)
                </button>
                 <button id="backToInputButton" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-xl transition duration-150 transform hover:scale-105">
                    å›ä¸Šä¸€æ­¥ (è®Šæ›´èªè©)
                </button>
            </div>
            
            <!-- Canvas å®¹å™¨ -->
            <div class="max-w-4xl w-full mx-auto aspect-square">
                 <canvas id="bingoCanvas"></canvas>
            </div>
            
            <!-- èªªæ˜ -->
            <div class="text-center mt-8 p-4 bg-white/70 rounded-lg backdrop-blur-sm max-w-4xl mx-auto shadow-md">
                <p class="text-gray-700 font-medium">ğŸ’¡ ç©æ³•ï¼šé»æ“Šå¡ç‰‡å¾ªç’°åˆ‡æ› **åœ–æ¡ˆ** â†’ **è§£é‡‹** â†’ **èªè© (æ¨™è¨˜)** ä¸‰ç¨®ç‹€æ…‹ï¼Œäº”å€‹é€£æˆä¸€ç·šå³è³“æœï¼</p>
                <p class="text-sm text-gray-500 mt-1">è¬ç”¨æ ¼ (PASS) åœ¨æ¨™è¨˜æ™‚æœ‰ç‰¹æ®Šé¡è‰²æç¤ºã€‚</p>
            </div>
        </div>
    </div>

  <script>
        // å¸¸æ•¸è¨­å®š
        const CARD_COUNT = 25; // 5x5
        const GRID_SIZE = 5; 
        const PADDING = 20; // Canvas é‚Šç•Œå¡«å……
        const SPACING = 12; // å¡ç‰‡é–“è·
        
        // ç”¨æ–¼å¡«å……éèªè©å¡ç‰‡çš„è¡¨æƒ…ç¬¦è™Ÿ
        const EMOJI_POOL = [
            "ğŸ", "ğŸŠ", "ğŸ‹", "ğŸ¥", "ğŸ‰", "ğŸ‡", "ğŸ“", "ğŸ’", 
            "ğŸ", "ğŸ‘", "ğŸ¥­", "ğŸ¥¥", "ğŸ¥‘", "ğŸ¥•", "ğŸ¥¦", "ğŸ„",
            "ğŸˆ", "ğŸ", "ğŸ‰", "ğŸŒŸ", "ğŸŒˆ", "ğŸ¦‹", "ğŸŒ", "ğŸŒ™", "âœï¸", "ğŸ“š"
        ];
        
        // éŠæˆ²ç‹€æ…‹è®Šæ•¸
        let canvas, ctx;
        let customVocabData = []; // å„²å­˜ä½¿ç”¨è€…è¼¸å…¥çš„ 25 çµ„è³‡æ–™
        let vocabulary = []; // ç•¶å‰è¢«æ‰“äº‚çš„èªè©é †åº (åŒ…å« PASS)
        let cardStates = []; // å¡ç‰‡ç‹€æ…‹ï¼š0=åœ–æ¡ˆ, 1=è§£é‡‹, 2=èªè©(æ¨™è¨˜)
        let markedLines = []; // å·²ç¶“é€£ç·šçš„ç´¢å¼•é™£åˆ—
        let cardSize = 0;

        // -----------------------
        // è¼”åŠ©å‡½å¼
        // -----------------------

        // éš¨æ©Ÿæ‰“äº‚é™£åˆ— (Fisher-Yates)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // æ’­æ”¾é»æ“ŠéŸ³æ•ˆ
        function playClickSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.05);
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.error("ç„¡æ³•æ’­æ”¾éŸ³æ•ˆ:", e);
            }
        }
        
        // é¡¯ç¤ºè¨Šæ¯æ¡†ï¼ˆå–ä»£ alert()ï¼‰
        function showMessage(title, message) {
            let messageBox = document.getElementById('messageBox');
            messageBox.innerHTML = `
                <div class="bg-white p-8 rounded-xl shadow-2xl max-w-sm text-center transform scale-100 transition-transform duration-300">
                    <div class="text-4xl mb-4">${title.includes("è³“æœ") ? "ğŸ‰" : "ğŸ’¡"}</div>
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">${title}</h2>
                    <p class="text-gray-600 mb-6">${message}</p>
                    <button onclick="document.getElementById('messageBox').classList.remove('active')" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-lg transition duration-150">
                        ç¢ºå®š
                    </button>
                </div>
            `;
             messageBox.classList.add('active');
        }

        // é¡¯ç¤ºå½©å¸¶ç•«é¢ (Confetti) 3ç§’
        function showConfetti() {
            const container = document.getElementById('confettiContainer');
            if (!container) return;
            
            container.innerHTML = ''; 
            container.style.opacity = '1';
            
            const colors = ['#f43f5e', '#6366f1', '#10b981', '#f59e0b', '#3b82f6']; 
            const count = 50; 

            for (let i = 0; i < count; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                const size = Math.random() * 8 + 4; 
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                
                const startX = Math.random() * 100 + 'vw';
                const endX = Math.random() * 100 + 'vw';

                confetti.style.setProperty('--startX', startX);
                confetti.style.setProperty('--endX', endX);

                confetti.style.animation = `confetti-fall 3s ease-in-out forwards`;
                confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                
                container.appendChild(confetti);
            }

            setTimeout(() => {
                container.style.opacity = '0';
                setTimeout(() => {
                    container.innerHTML = '';
                }, 500); 
            }, 3000);
        }
        
        // -----------------------
        // éšæ®µä¸€ï¼šè¼¸å…¥ä»‹é¢é‚è¼¯ (DOM)
        // -----------------------

        // ç”Ÿæˆè¼¸å…¥æ¬„ä½ - åƒ…ç”Ÿæˆ Textarea
        function generateInputFields() {
            // Textarea å·²å¯«æ­»åœ¨ HTML ä¸­ï¼Œé€™è£¡ä¸éœ€è¦å‹•æ…‹ç”Ÿæˆï¼Œä½†ä¿ç•™å‡½æ•¸çµæ§‹ã€‚
        }
        
        /**
         * æ”¶é›†ä¸¦è§£æ Textarea ä¸­çš„è³‡æ–™ã€‚
         * æ ¼å¼ï¼šèªè©:è§£é‡‹ ä¾‹å¥...ï¼Œæ¯è¡Œä¸€çµ„ã€‚
         */
        function collectAndValidateInput() {
            const inputElement = document.getElementById('vocabInput');
            const rawText = inputElement.value.trim();
            const collectedData = [];
            const inputError = document.getElementById('inputError');
            inputError.textContent = '';
            
            if (rawText === '') {
                 inputError.textContent = 'éŒ¯èª¤ï¼šè«‹åœ¨æ–‡å­—å€åŸŸå…§è¼¸å…¥èªè©èˆ‡è§£é‡‹ã€‚';
                 return null;
            }

            // 1. æŒ‰è¡Œåˆ†å‰²
            const lines = rawText.split('\n');
            
            // 2. è™•ç†æ¯ä¸€è¡Œ
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue; // è·³éç©ºè¡Œ

                // å°‹æ‰¾å…¨å½¢å†’è™Ÿä½œç‚ºèªè©å’Œå…§å®¹çš„åˆ†éš”ç¬¦
                const separatorIndex = line.indexOf('ï¼š');
                
                if (separatorIndex === -1) {
                    inputError.textContent = `éŒ¯èª¤ï¼šç¬¬ ${i + 1} è¡Œæ ¼å¼ä¸æ­£ç¢ºï¼Œè«‹æª¢æŸ¥æ˜¯å¦æœ‰ä½¿ç”¨å…¨å½¢å†’è™Ÿã€Œï¼šã€ã€‚`;
                    return null;
                }
                
                // --- æ­¥é©Ÿ 1: æå–åŸå§‹èªè©å’Œå…§å®¹ ---
                let term = line.substring(0, separatorIndex).trim();
                let definitionContent = line.substring(separatorIndex + 1).trim();

                // --- æ­¥é©Ÿ 2: æ¸…ç†èªè© (ç§»é™¤å¸¸è¦‹çš„é–‹é ­ç·¨è™Ÿ/ç¬¦è™Ÿ) ---
                // ç§»é™¤é–‹é ­çš„æ•¸å­—ã€é»è™Ÿã€åœ“åœˆæ•¸å­—ã€å…¨å½¢ç¬¦è™Ÿã€ç©ºæ ¼ç­‰å¸¸è¦‹ç·¨è™Ÿ
                // \s*[\u2460-\u2473\u3220-\u3229\uFF10-\uFF19\u2488-\u249b\u2160-\u217f\uFF08\uFF09\uFF1A\u3007\u3001\u3002] åŒ…å«äº†å„ç¨®å¸¸è¦‹ç·¨è™Ÿå­—ç¬¦
                // ä½¿ç”¨ä¸€å€‹æ›´é€šç”¨çš„æ­£å‰‡è¡¨é”å¼ä¾†è™•ç†é–‹é ­çš„ç·¨è™Ÿã€é»è™Ÿå’Œç©ºæ ¼
                term = term.replace(/^[\s\d\.()ï¼ˆï¼‰]+|^[\s]*[\u2460-\u2473\u3220-\u3229\uFF10-\uFF19\u2488-\u249b\u2160-\u217f\uFF08\uFF09\uFF1A\u3007\u3001\u3002\uFF0E\uFF61\u3003\u300A\u300B]\s*/, '').trim();


                // --- æ­¥é©Ÿ 3: å¾å…§å®¹ä¸­æŠ“å–è§£é‡‹ (å¿½ç•¥ä¾‹å¥) ---
                const exampleIndex = definitionContent.indexOf('ä¾‹å¥');

                let definition = definitionContent;
                if (exampleIndex !== -1) {
                    // å¦‚æœæ‰¾åˆ°ã€Œä¾‹å¥ã€ï¼Œåªå–å…¶å‰é¢çš„éƒ¨åˆ†
                    definition = definitionContent.substring(0, exampleIndex).trim();
                }
                
                // æª¢æŸ¥èªè©æˆ–è§£é‡‹æ˜¯å¦ç‚ºç©º
                if (term === '' || definition === '') {
                    inputError.textContent = `éŒ¯èª¤ï¼šç¬¬ ${i + 1} è¡Œèªè©æˆ–è§£é‡‹æå–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ ¼å¼ã€‚`;
                    return null;
                }
                
                // åªæ”¶é›†å‰ 25 çµ„
                if (collectedData.length < CARD_COUNT) {
                    collectedData.push({ term, definition });
                }
            }
            
            if (collectedData.length === 0) {
                 inputError.textContent = 'éŒ¯èª¤ï¼šè«‹è‡³å°‘è¼¸å…¥ä¸€çµ„æœ‰æ•ˆçš„èªè©èˆ‡è§£é‡‹ã€‚';
                 return null;
            }

            return collectedData;
        }

        // å•Ÿå‹•éŠæˆ²çš„è™•ç†ç¨‹åº
        function handleStartGame() {
            const collectedData = collectAndValidateInput();
            if (collectedData) {
                customVocabData = collectedData;
                
                // åˆ‡æ›ä»‹é¢
                document.getElementById('inputArea').classList.add('hidden');
                document.getElementById('gameArea').classList.remove('hidden');
                
                // åˆå§‹åŒ– Canvas éŠæˆ²
                setupGame();
            }
        }

        // æ–°å¢ï¼šæ¸…ç©ºè¼¸å…¥æ¬„ä½å…§å®¹
        function clearInput() {
            document.getElementById('vocabInput').value = '';
            document.getElementById('inputError').textContent = '';
        }
        
        // -----------------------
        // éšæ®µäºŒï¼šè³“æœéŠæˆ²é‚è¼¯ (Canvas)
        // -----------------------

        // ç¢ºä¿ Canvas å°ºå¯¸ç¬¦åˆå®¹å™¨
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight);
            
            canvas.width = size;
            canvas.height = size;

            // è¨ˆç®—å¡ç‰‡å¤§å°
            cardSize = (size - 2 * PADDING - (GRID_SIZE - 1) * SPACING) / GRID_SIZE;
            
            // FIX: ç¢ºä¿å¡ç‰‡å¤§å°ä¸ç‚ºè² ï¼Œé˜²æ­¢ Canvas ç¹ªåœ–éŒ¯èª¤ (IndexSizeError: radius is negative)
            if (cardSize <= 0) {
                cardSize = 0; 
                if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
                return; // å°ºå¯¸å¤ªå°ï¼Œåœæ­¢ç¹ªåœ–
            }

            // é‡æ–°ç¹ªè£½æ•´å€‹éŠæˆ²
            if (vocabulary.length === CARD_COUNT) {
                 drawGame();
            }
        }

        // ç¹ªè£½å–®ä¸€å¡ç‰‡
        function drawCard(index, x, y) {
            const item = vocabulary[index];
            const state = cardStates[index];
            const radius = 10;
            const w = cardSize;
            const h = cardSize;

            ctx.save();
            ctx.translate(x, y);

            // 1. ç¹ªè£½åœ“è§’çŸ©å½¢èƒŒæ™¯
            ctx.beginPath();
            ctx.moveTo(radius, 0);
            ctx.lineTo(w - radius, 0);
            ctx.quadraticCurveTo(w, 0, w, radius);
            ctx.lineTo(w, h - radius);
            ctx.quadraticCurveTo(w, h, w - radius, h);
            ctx.lineTo(radius, h);
            ctx.quadraticCurveTo(0, h, 0, h - radius);
            ctx.lineTo(0, radius);
            ctx.quadraticCurveTo(0, 0, radius, 0);
            ctx.closePath();
            
            // è¨­ç½®æ¼¸è®Šé¡è‰²
            let gradient;
            let borderColor = '#ccc';
            
            if (state === 0) {
                // åœ–æ¡ˆç‹€æ…‹ (é»ƒ-æ©™) - é©ç”¨æ–¼æ‰€æœ‰å¡ç‰‡ (åŒ…æ‹¬ PASSï¼Œä»¥ä¿æŒä¸€è‡´æ€§)
                gradient = ctx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, '#FFFBEB'); // yellow-50
                gradient.addColorStop(1, '#FFEDD5'); // orange-100
                borderColor = '#FCD34D'; // yellow-400
            } else if (state === 1) {
                // è§£é‡‹ç‹€æ…‹ (è—-ç´«) - åƒ…é©ç”¨æ–¼é PASS
                gradient = ctx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, '#EEF2FF'); // indigo-50
                gradient.addColorStop(1, '#E0E7FF'); // indigo-100
                borderColor = '#6366F1'; // indigo-500
            } else { // state === 2 (èªè©/æ¨™è¨˜ç‹€æ…‹)
                // èªè©/æ¨™è¨˜ç‹€æ…‹ (ç¶ -é’) - é è¨­ç”¨æ–¼æ™®é€šå¡ç‰‡
                gradient = ctx.createLinearGradient(0, 0, w, h);
                gradient.addColorStop(0, '#F0FFF4'); // green-50
                gradient.addColorStop(1, '#E0F2F1'); // teal-100
                borderColor = '#10B981'; // emerald-500
                
                // è¬ç”¨æ ¼ç‰¹æ®Šè™•ç†ï¼šPASS å¡åœ¨æ¨™è¨˜æ™‚ä½¿ç”¨é‡‘è‰²ï¼Œä»¥å‡¸é¡¯å…¶ç‰¹æ®Šæ€§
                if (item.isPass) {
                    gradient = ctx.createLinearGradient(0, 0, w, h);
                    gradient.addColorStop(0, '#FFFDD0'); // å¥¶æ²¹é»ƒ
                    gradient.addColorStop(1, '#FFDB8B'); // é‡‘è‰²
                    borderColor = '#FFD700'; // é‡‘è‰²é‚Šæ¡†
                }
            }


            ctx.fillStyle = gradient;
            ctx.fill();
            
            // ç¹ªè£½é‚Šæ¡†
            // åªæœ‰åœ¨ PASS å¡ç‰‡è™•æ–¼æ¨™è¨˜ç‹€æ…‹ (State 2) æ™‚ï¼Œé‚Šæ¡†æ‰è®Šç²—ï¼Œå…¶é¤˜éƒ½ç‚º 2px
            ctx.lineWidth = (item.isPass && state === 2) ? 4 : 2;
            ctx.strokeStyle = borderColor;
            ctx.stroke();

            // 2. ç¹ªè£½å…§å®¹
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const centerX = w / 2;
            const centerY = h / 2;

            if (state === 0) {
                // ç¹ªè£½ Emoji åœ–æ¡ˆ (æ‰€æœ‰å¡ç‰‡ï¼ŒåŒ…æ‹¬ PASSï¼Œéƒ½é¡¯ç¤ºåˆ†é…åˆ°çš„ emoji)
                ctx.font = `${w * 0.4}px Noto Sans TC`;
                ctx.fillText(item.emoji, centerX, centerY);
                
            } else if (state === 1) {
                // ç¹ªè£½è§£é‡‹æ–‡å­—
                const text = item.definition;
                ctx.fillStyle = '#4B5563'; // gray-700
                
                // è¤‡é›œçš„ Canvas è‡ªå‹•æ›è¡Œè™•ç†
                const max_width = w * 0.9;
                let line_height = w * 0.12;
                ctx.font = `${line_height}px Noto Sans TC`;
                let lines = [];
                let current_line = '';
                
                const words = Array.from(text);
                
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const test_line = current_line + word;
                    
                    if (ctx.measureText(test_line).width > max_width && i > 0) {
                        lines.push(current_line);
                        current_line = word;
                    } else {
                        current_line = test_line;
                    }
                }
                lines.push(current_line);

                let startY = centerY - (lines.length - 1) * line_height / 2;
                
                lines.forEach((line, i) => {
                    ctx.fillText(line, centerX, startY + i * line_height);
                });

            } else {
                // ç¹ªè£½èªè© (æ¨™è¨˜ç‹€æ…‹)
                let termText = item.isPass ? "PASS" : item.term;
                ctx.fillStyle = '#1F2937'; // gray-900
                
                // æ ¹æ“šå­—æ•¸èª¿æ•´å­—é«”å¤§å°
                let termFontSize = w * 0.35;
                if (termText.length >= 5) termFontSize = w * 0.28;
                if (termText.length >= 7) termFontSize = w * 0.22;
                
                ctx.font = `bold ${termFontSize}px Noto Sans TC`;
                ctx.fillText(termText, centerX, centerY);

                // ç¹ªè£½æ¨™è¨˜åœ“åœˆ (è¼•å¾®è¦–è¦ºæç¤º)
                ctx.beginPath();
                // ç”±æ–¼ cardSize å·²ç¶“æª¢æŸ¥é >= 0ï¼Œé€™è£¡çš„åŠå¾‘ç¢ºä¿ >= 0
                ctx.arc(centerX, centerY, w * 0.45, 0, Math.PI * 2); 
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)'; // red-400 semi-transparent
                ctx.lineWidth = 6;
                ctx.stroke();
            }

            ctx.restore();
        }

        // ç¹ªè£½è³“æœé€£ç·š
        function drawBingoLines() {
            ctx.save();
            ctx.lineWidth = 10;
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.9)'; // red-500
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(239, 68, 68, 0.8)';
            ctx.shadowBlur = 15;

            const halfCard = cardSize / 2;
            
            markedLines.forEach(indices => {
                const startIdx = indices[0];
                const endIdx = indices[indices.length - 1];

                const startRow = Math.floor(startIdx / GRID_SIZE);
                const startCol = startIdx % GRID_SIZE;
                const endRow = Math.floor(endIdx / GRID_SIZE);
                const endCol = endIdx % GRID_SIZE;
                
                // è¨ˆç®—å¡ç‰‡ä¸­å¿ƒé» (ç›¸å°æ–¼ Canvas åŸé»)
                const getCenter = (row, col) => ({
                    x: PADDING + col * (cardSize + SPACING) + halfCard,
                    y: PADDING + row * (cardSize + SPACING) + halfCard
                });
                
                const startCenter = getCenter(startRow, startCol);
                const endCenter = getCenter(endRow, endCol);

                ctx.beginPath();
                ctx.moveTo(startCenter.x, startCenter.y);
                ctx.lineTo(endCenter.x, endCenter.y);
                ctx.stroke();
            });

            ctx.restore();
        }

        // ç¹ªè£½æ•´å€‹éŠæˆ²ç›¤é¢
        function drawGame() {
            // FIX: ç¢ºä¿æœ‰ä¸Šä¸‹æ–‡ä¸”å¡ç‰‡å¤§å°æœ‰æ•ˆ (ä¿®æ­£ï¼šé˜²æ­¢è² åŠå¾‘éŒ¯èª¤)
            if (!ctx || cardSize <= 0) return; 

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½ 5x5 å¡ç‰‡
            for (let i = 0; i < CARD_COUNT; i++) {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;
                
                const x = PADDING + col * (cardSize + SPACING);
                const y = PADDING + row * (cardSize + SPACING);
                
                drawCard(i, x, y);
            }
            
            // ç¹ªè£½é€£ç·š
            drawBingoLines();
        }

        // è™•ç†é»æ“Šäº‹ä»¶
        function handleCanvasClick(event) {
            if (!cardSize) return;

            // ç²å–é»æ“Šåœ¨ Canvas ä¸Šçš„ç›¸å°åº§æ¨™
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // æ”¯æ´æ»‘é¼ é»æ“Šå’Œè§¸æ‘¸é»æ“Š
            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;
            
            const clickX = (clientX - rect.left) * scaleX;
            const clickY = (clientY - rect.top) * scaleY;
            
            // è¨ˆç®—é»æ“Šè½åœ¨å“ªå€‹å¡ç‰‡ç´¢å¼•ä¸Š
            for (let i = 0; i < CARD_COUNT; i++) {
                const row = Math.floor(i / GRID_SIZE);
                const col = i % GRID_SIZE;
                
                const cardX = PADDING + col * (cardSize + SPACING);
                const cardY = PADDING + row * (cardSize + SPACING);

                // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨å¡ç‰‡çš„æœ‰æ•ˆç¯„åœå…§ (åŒ…å«é–“è· SPACING ä»¥å¤–çš„å¡ç‰‡å€åŸŸ)
                if (clickX >= cardX && clickX < cardX + cardSize &&
                    clickY >= cardY && clickY < cardY + cardSize) {
                    
                    toggleCard(i); // åˆ‡æ›å¡ç‰‡ç‹€æ…‹
                    return;
                }
            }
        }
        
        // åˆ‡æ›å¡ç‰‡ç‹€æ…‹
        function toggleCard(index) {
            playClickSound();
            const item = vocabulary[index];
            
            if (item.isPass) {
                // PASSå¡ç‰‡ï¼š0 (åœ–æ¡ˆ) <-> 2 (PASS æ¨™è¨˜)ï¼Œè·³éè§£é‡‹ç‹€æ…‹
                if (cardStates[index] === 0) {
                    cardStates[index] = 2; // æ¨™è¨˜
                } else {
                    cardStates[index] = 0; // å–æ¶ˆæ¨™è¨˜
                }
            } else {
                // ä¸€èˆ¬å¡ç‰‡ï¼šå¾ªç’° 0 (åœ–æ¡ˆ) -> 1 (è§£é‡‹) -> 2 (èªè©æ¨™è¨˜) -> 0 (åœ–æ¡ˆ)
                cardStates[index] = (cardStates[index] + 1) % 3;
            }

            // é‡æ–°ç¹ªè£½
            drawGame();
            
            checkForBingo(); // æª¢æŸ¥è³“æœ
        }
        
        // æª¢æŸ¥æ˜¯å¦é”æˆè³“æœ
        function checkForBingo() {
            const size = GRID_SIZE; 
            const currentMarkedLines = []; 
            
            // åˆ¤æ–·å“ªäº›å¡ç‰‡è¢«æ¨™è¨˜ (ç‹€æ…‹ 2)
            const isMarked = (i) => cardStates[i] === 2;
            
            function addLine(indices) {
                if (indices.every(isMarked)) {
                    currentMarkedLines.push(indices);
                }
            }

            // æª¢æŸ¥æ©«æ’ (Rows)
            for (let i = 0; i < size; i++) {
                const rowIndices = [];
                for (let j = 0; j < size; j++) {
                    rowIndices.push(i * size + j);
                }
                addLine(rowIndices);
            }

            // æª¢æŸ¥ç›´è¡Œ (Columns)
            for (let j = 0; j < size; j++) {
                const colIndices = [];
                for (let i = 0; i < size; i++) {
                    colIndices.push(i * size + j);
                }
                addLine(colIndices);
            }

            // æª¢æŸ¥å°è§’ç·š (Diagonals)
            const diag1Indices = []; 
            for (let i = 0; i < size; i++) {
                diag1Indices.push(i * size + i);
            }
            addLine(diag1Indices);

            const diag2Indices = []; 
            for (let i = 0; i < size; i++) {
                diag2Indices.push(i * size + (size - 1 - i));
            }
            addLine(diag2Indices);
            
            const previousLineCount = markedLines.length;
            markedLines = currentMarkedLines; // æ›´æ–°é€£ç·šç‹€æ…‹
            
            if (markedLines.length > previousLineCount) {
                // åªæœ‰ç•¶é€£ç·šæ•¸å¢åŠ æ™‚æ‰å½ˆå‡ºæ­å–œè¨Šæ¯å’Œå½©å¸¶
                showMessage("è³“æœï¼", `æ­å–œæ‚¨é”æˆ ${markedLines.length} æ¢é€£ç·šï¼`);
                showConfetti();
            }
            
            drawGame(); // é‡æ–°ç¹ªè£½ä»¥é¡¯ç¤º/æ›´æ–°é€£ç·š
        }

        // åˆå§‹åŒ–éŠæˆ²æ•¸æ“šå’Œ Canvas
        function setupGame() {
            // 1. æº–å‚™èªè©åˆ—è¡¨
            let currentVocab = [...customVocabData];
            
            // 2. å¡«å…… PASS å¡ç‰‡ï¼Œç›´åˆ°æ»¿ 25 å€‹
            const passNeeded = CARD_COUNT - currentVocab.length;
            // ç¢ºä¿èªè©æ•¸é‡ä¸èƒ½è¶…é 25ï¼Œä½†å› ç‚º collectAndValidateInput å·²ç¶“é™åˆ¶äº†ï¼Œæ‰€ä»¥é€™è£¡ä¸»è¦æ˜¯è™•ç†ä¸è¶³çš„æƒ…æ³ã€‚
            if (passNeeded > 0) {
                for (let i = 0; i < passNeeded; i++) {
                    currentVocab.push({ 
                        term: "PASS", 
                        definition: "è¬ç”¨æ ¼ï¼Œå¯è‡ªç”±é¸æ“‡æ˜¯å¦ç¿»é–‹ã€‚", 
                        isPass: true 
                    });
                }
            }
            
            // 3. æ‰“äº‚é †åº
            vocabulary = shuffleArray(currentVocab);
            
            // 4. åˆ†é…ä¸¦æ‰“äº‚è¡¨æƒ…ç¬¦è™Ÿ
            const shuffledEmojis = shuffleArray(EMOJI_POOL);
            vocabulary.forEach((item, index) => {
                // çµ±ä¸€ç‚ºæ‰€æœ‰å¡ç‰‡ï¼ˆåŒ…æ‹¬ PASS å¡ï¼‰éš¨æ©Ÿåˆ†é…è¡¨æƒ…ç¬¦è™Ÿ
                item.emoji = shuffledEmojis[index % shuffledEmojis.length]; 
            });
            
            // 5. é‡è¨­ç‹€æ…‹
            cardStates = new Array(vocabulary.length).fill(0); // åˆå§‹ç‹€æ…‹ï¼šåœ–æ¡ˆ
            markedLines = [];
            
            // 6. ç¢ºä¿ Canvas å·²ç¶“åˆå§‹åŒ–ä¸¦é‡ç¹ª
            if (!canvas) {
                 canvas = document.getElementById('bingoCanvas');
                 ctx = canvas.getContext('2d');
            }
            resizeCanvas(); // é‡æ–°è¨ˆç®—å¤§å°ä¸¦ç¹ªè£½
        }


        // -----------------------
        // ç¨‹å¼åˆå§‹åŒ–
        // -----------------------
        
        document.addEventListener('DOMContentLoaded', () => {
            // 1. åˆå§‹ç”Ÿæˆè¼¸å…¥æ¬„ä½ (DOM) - åªéœ€è¦ç¢ºä¿ Textarea å­˜åœ¨
            generateInputFields();
            
            // 2. è¨­ç½® Canvas éŸ¿æ‡‰å¼èª¿æ•´
            window.addEventListener('resize', resizeCanvas);

            // 3. ç²å– Canvas å…ƒç´ ä¸¦ç¶å®šé»æ“Šäº‹ä»¶ (æ”¯æ´è§¸æ‘¸äº‹ä»¶)
            canvas = document.getElementById('bingoCanvas');
            ctx = canvas.getContext('2d');
            canvas.addEventListener('click', handleCanvasClick);
            // æ”¯æ´è§¸æ‘¸äº‹ä»¶
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // é¿å…è§¸æ‘¸æ™‚æ»¾å‹•
                handleCanvasClick(e);
            });
            
            // 4. ç¶å®šæŒ‰éˆ•äº‹ä»¶ï¼šå•Ÿå‹•éŠæˆ²
            const startGameButton = document.getElementById('startGameButton');
            startGameButton.addEventListener('click', handleStartGame);
            
            // 4.5 ç¶å®šæŒ‰éˆ•äº‹ä»¶ï¼šä¸€éµæ¸…ç©º
            const clearInputButton = document.getElementById('clearInputButton');
            clearInputButton.addEventListener('click', clearInput);

            // 5. ç¶å®šæŒ‰éˆ•äº‹ä»¶ï¼šé‡æ–°é–‹å§‹ (éŠæˆ²ä¸­)
            const resetButton = document.getElementById('resetButton');
            resetButton.addEventListener('click', () => {
                 setupGame(); // é‡æ–°æ‰“äº‚ä¸¦é‡è¨­ç‹€æ…‹ï¼Œä½†ä¸è®Šæ›´èªè©
            });

            // 6. ç¶å®šæŒ‰éˆ•äº‹ä»¶ï¼šå›ä¸Šä¸€æ­¥ (éŠæˆ²ä¸­)
            const backToInputButton = document.getElementById('backToInputButton');
            backToInputButton.addEventListener('click', () => {
                document.getElementById('gameArea').classList.add('hidden');
                document.getElementById('inputArea').classList.remove('hidden');
                markedLines = []; // æ¸…é™¤ Canvas ä¸Šçš„é€£ç·šç‹€æ…‹
            });
            
            // 7. ç¢ºä¿ä¸€é–‹å§‹å°±æ¸…ç©ºè¼¸å…¥æ¡†ï¼Œåªç•™ä¸‹ placeholder
            clearInput();
        });
    </script>
 </body>
</html>