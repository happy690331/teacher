<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨é€šç”¨é›™æ¬„è€ƒå· - ç²¾æº–å¯¦å¢ƒå ±è®€ç³»çµ±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body {
            font-family: "Microsoft JhengHei", sans-serif;
            background-color: #2c3e50;
            color: #333;
            margin: 0;
            padding: 0;
            padding-bottom: 60px;
        }

        #control-panel {
            position: sticky;
            top: 0;
            background-color: #ffffff;
            padding: 15px 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }

        .title-area h1 { margin: 0; font-size: 20px; color: #2c3e50; font-weight: bold; }
        .title-area p { margin: 5px 0 0 0; font-size: 14px; color: #7f8c8d; }

        .controls { display: flex; align-items: center; gap: 10px; }
        button {
            background-color: #3498db; color: white; border: none;
            padding: 8px 12px; border-radius: 6px; font-size: 15px;
            cursor: pointer; font-weight: bold; transition: all 0.2s;
        }
        button:hover { background-color: #2980b9; }
        button.btn-stop { background-color: #e74c3c; }
        button.btn-pause { background-color: #f39c12; }
        button.btn-resume { background-color: #2ecc71; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .speed-control {
            display: flex; align-items: center; gap: 8px; font-weight: bold;
            background: #f1f2f6; padding: 5px 10px; border-radius: 6px;
        }

        #upload-screen {
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; height: 80vh; color: white; gap: 20px;
        }
        .upload-box {
            background: rgba(255,255,255,0.1); padding: 30px; border-radius: 12px;
            text-align: center; border: 2px dashed #ecf0f1; width: 80%; max-width: 500px;
        }
        .upload-box input[type="file"] {
            margin-top: 15px; font-size: 16px; color: white; width: 100%;
        }
        .upload-box input[type="text"] {
            margin-top: 15px; font-size: 16px; padding: 8px; width: 70%; border-radius: 4px; border: none;
        }
        .upload-box button.fetch-btn {
            margin-top: 15px; background-color: #e67e22; font-size: 16px;
        }
        .upload-box button.fetch-btn:hover { background-color: #d35400; }
        
        #loading-screen {
            display: none; color: white; text-align: center; margin-top: 50px; font-size: 20px;
        }

        #pdf-viewer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px auto;
            width: 100%;
            opacity: 0; 
            transition: opacity 0.5s;
        }

        .pdf-page {
            position: relative; 
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background-color: white;
        }

        .pdf-page canvas { display: block; }

        .textLayer {
            position: absolute; left: 0; top: 0; right: 0; bottom: 0;
            color: transparent; pointer-events: none; overflow: hidden;
        }
        .textLayer span {
            position: absolute; white-space: pre; transform-origin: 0% 0%;
        }

        .boxLayer {
            position: absolute; left: 0; top: 0; right: 0; bottom: 0;
            pointer-events: none; 
        }

        .q-box {
            position: absolute;
            border: 2px solid rgba(231, 76, 60, 0.7);
            border-radius: 4px;
            background-color: rgba(231, 76, 60, 0.03);
            cursor: pointer;
            pointer-events: auto; 
            transition: all 0.2s;
        }

        .q-box:hover {
            background-color: rgba(231, 76, 60, 0.15);
            border-color: rgba(231, 76, 60, 1);
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.4);
        }

        .q-box.reading {
            background-color: rgba(241, 196, 15, 0.25); 
            border-color: #e67e22;
            border-width: 3px;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.6);
            z-index: 10;
        }

        .q-box.paused {
            background-color: rgba(189, 195, 199, 0.4);
            border-style: dashed;
            border-color: #7f8c8d;
        }

        .progress-container {
            position: absolute;
            bottom: -6px; 
            left: -2px; 
            width: calc(100% + 4px);
            height: 6px;
            background-color: #ecf0f1;
            border-radius: 2px;
            overflow: hidden;
            display: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .q-box.reading .progress-container, 
        .q-box.paused .progress-container {
            display: block;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: #2ecc71; 
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

    <div id="control-panel">
        <div class="title-area">
            <h1>å…¨é€šç”¨é›™æ¬„è€ƒå· - å¯¦å¢ƒå ±è®€ç³»çµ±</h1>
            <p id="status-text">è«‹é¸æ“‡è¼‰å…¥æ–¹å¼ï¼šæœ¬æ©Ÿä¸Šå‚³ æˆ– GitHub é¡Œåº«ä¸‹è¼‰ã€‚</p>
        </div>
        <div class="controls">
            <div class="speed-control">
                <label for="speedRate">èªé€Ÿï¼š</label>
                <input type="range" id="speedRate" min="0.5" max="1.5" step="0.1" value="1.0">
                <span id="speedValue">1.0</span>
            </div>
            <button class="btn-pause" id="btnPause" onclick="pauseReading()" disabled>â¸ï¸ æš«åœ</button>
            <button class="btn-resume" id="btnResume" onclick="resumeReading()" disabled>â–¶ï¸ ç¹¼çºŒ</button>
            <button class="btn-stop" id="btnStop" onclick="stopReading()" disabled>â¹ï¸ åœæ­¢</button>
        </div>
    </div>

    <div id="upload-screen">
        <div class="upload-box">
            <h2>ğŸ“ æ–¹å¼ä¸€ï¼šå¾æœ¬æ©Ÿä¸Šå‚³è€ƒå· PDF</h2>
            <p>æ”¯æ´ä»»ä½•æ¨™æº–ç›´å¼é›™æ¬„è€ƒå·</p>
            <input type="file" id="pdf-upload" accept="application/pdf">
        </div>
        <div class="upload-box">
            <h2>ğŸŒ æ–¹å¼äºŒï¼šå¾ GitHub é¡Œåº«è¼‰å…¥</h2>
            <p style="font-size: 13px; color: #bdc3c7;">ä¾†æº: happy690331/teacher/tree/main/exam paper</p>
            <button class="fetch-btn" id="btn-fetch-list" onclick="fetchGitHubList()">ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨</button>
            <select id="github-select" style="display:none; margin-top: 15px; font-size: 16px; padding: 8px; width: 90%; border-radius: 4px; border: none;"></select>
            <button class="fetch-btn" id="btn-load-selected" onclick="loadSelectedGitHub()" style="display:none; background-color: #27ae60; margin-top: 10px;">ğŸš€ è¼‰å…¥é¸æ“‡çš„è€ƒå·</button>
        </div>
    </div>
    
    <div id="loading-screen">ç³»çµ±æ­£åœ¨å•Ÿå‹•ã€Œç²¾æº–é›™æ¬„ç‰©ç†åˆ‡åˆ†ã€èˆ‡ã€ŒAIè‡ªå‹•é¡Œè™Ÿè¾¨è­˜ã€ï¼Œè«‹ç¨å€™... âš™ï¸</div>

    <div id="pdf-viewer"></div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // ==========================================
        // è¼‰å…¥é‚è¼¯ï¼šæœ¬æ©Ÿä¸Šå‚³ æˆ– GitHub ä¸‹è¼‰
        // ==========================================
        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                showLoading();
                setTimeout(() => {
                    const fileReader = new FileReader();
                    fileReader.onload = function() {
                        const typedarray = new Uint8Array(this.result);
                        renderPDFAndExtractCoordinates(typedarray);
                    };
                    fileReader.readAsArrayBuffer(file);
                }, 100);
            }
        });

        async function fetchGitHubList() {
            const btnFetch = document.getElementById('btn-fetch-list');
            btnFetch.innerText = 'è®€å–æ¸…å–®ä¸­... â³';
            btnFetch.disabled = true;

            try {
                // ä½¿ç”¨ GitHub å®˜æ–¹ API ç²å–è³‡æ–™å¤¾å…§çš„æª”æ¡ˆæ¸…å–®
                const apiUrl = "https://api.github.com/repos/happy690331/teacher/contents/exam%20paper?ref=main";
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error("ç„¡æ³•å–å¾—ç·šä¸Šæ¸…å–®");
                const data = await response.json();

                // ç¯©é¸å‡ºé™„æª”åç‚º .pdf çš„æª”æ¡ˆ
                const pdfFiles = data.filter(item => item.name.toLowerCase().endsWith('.pdf'));

                if (pdfFiles.length === 0) {
                    alert("è©²è³‡æ–™å¤¾ä¸‹æ²’æœ‰æ‰¾åˆ° PDF æª”æ¡ˆï¼");
                    btnFetch.innerText = 'ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨';
                    btnFetch.disabled = false;
                    return;
                }

                // å°‡æª”æ¡ˆå¡«å…¥ä¸‹æ‹‰é¸å–®ä¸­
                const selectElement = document.getElementById('github-select');
                selectElement.innerHTML = '<option value="">-- è«‹é¸æ“‡ä¸€ä»½è€ƒå· --</option>';
                pdfFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.download_url; // API æä¾›çš„ raw åŸå§‹æª”ä¸‹è¼‰ç¶²å€
                    option.textContent = file.name;
                    selectElement.appendChild(option);
                });

                // éš±è—è®€å–æŒ‰éˆ•ï¼Œé¡¯ç¤ºä¸‹æ‹‰é¸å–®èˆ‡è¼‰å…¥æŒ‰éˆ•
                btnFetch.style.display = 'none';
                selectElement.style.display = 'block';
                document.getElementById('btn-load-selected').style.display = 'inline-block';

            } catch (error) {
                alert("ç²å–æ¸…å–®å¤±æ•—ï¼š" + error.message);
                btnFetch.innerText = 'ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨';
                btnFetch.disabled = false;
            }
        }

        async function loadSelectedGitHub() {
            const selectElement = document.getElementById('github-select');
            const fetchUrl = selectElement.value;
            
            if (!fetchUrl) {
                alert("è«‹å…ˆå¾ä¸‹æ‹‰é¸å–®é¸æ“‡ä¸€ä»½è€ƒå·ï¼");
                return;
            }

            showLoading();

            try {
                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error("æ‰¾ä¸åˆ°æª”æ¡ˆ (HTTP " + response.status + ")");
                const arrayBuffer = await response.arrayBuffer();
                const typedarray = new Uint8Array(arrayBuffer);
                renderPDFAndExtractCoordinates(typedarray);
            } catch (error) {
                alert("ç„¡æ³•å¾ GitHub è¼‰å…¥æª”æ¡ˆï¼\nè©³ç´°éŒ¯èª¤ï¼š" + error.message);
                hideLoading();
            }
        }

        function showLoading() {
            document.getElementById('upload-screen').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'block';
            document.getElementById('pdf-viewer').style.opacity = '0';
        }

        function hideLoading() {
            document.getElementById('upload-screen').style.display = 'flex';
            document.getElementById('loading-screen').style.display = 'none';
        }

        // ==========================================
        // æ ¸å¿ƒè§£æèˆ‡å‹•æ…‹é¡Œåº«ç”Ÿæˆå¼•æ“
        // ==========================================
        async function renderPDFAndExtractCoordinates(pdfData) {
            const pdf = await pdfjsLib.getDocument(pdfData).promise;
            const viewer = document.getElementById('pdf-viewer');
            viewer.innerHTML = '';
            
            let allChars = []; 

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 2.0 });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.style.width = viewport.width + 'px';
                pageDiv.style.height = viewport.height + 'px';
                
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                pageDiv.appendChild(canvas);
                
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'textLayer';
                pageDiv.appendChild(textLayerDiv);
                
                const boxLayerDiv = document.createElement('div');
                boxLayerDiv.className = 'boxLayer';
                pageDiv.appendChild(boxLayerDiv);

                viewer.appendChild(pageDiv);

                await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;

                const textContent = await page.getTextContent();
                await pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                }).promise;

                const spans = textLayerDiv.querySelectorAll('span');
                const pageRect = pageDiv.getBoundingClientRect();

                spans.forEach(span => {
                    const text = span.textContent;
                    if (!text.trim()) return;

                    const rect = span.getBoundingClientRect();
                    const spanLeft = rect.left - pageRect.left;
                    const spanTop = rect.top - pageRect.top;
                    const charWidth = rect.width / text.length;
                    
                    for (let i = 0; i < text.length; i++) {
                        let char = text[i];
                        // ã€å‡ç´šã€‘ï¼šåŠ å…¥ \u3000-\u303F ç¢ºä¿ã€Œã€ã€ã€ã€Œï¼šã€ã€ã€Œï¼Œã€ç­‰ä¸­æ–‡æ¨™é»ä¸æœƒè¢«éæ¿¾æ‰ï¼
                        let sanitized = char.replace(/[^\u4e00-\u9fa5a-zA-Z0-9\u2000-\u2BFF\u3000-\u303F\u3105-\u312F\uF000-\uF8FF\(\)ï¼ˆï¼‰\.\?ã€‚ï¼ŸË‡ï¼š:,ï¼Œï¼›!ï¼]/g, '');
                        if (sanitized) {
                            allChars.push({
                                char: char,
                                layer: boxLayerDiv,
                                left: spanLeft + (i * charWidth),
                                top: spanTop,
                                width: charWidth,
                                height: rect.height,
                                pageIndex: pageNum,
                                pageMidX: viewport.width / 2 
                            });
                        }
                    }
                });
            }

            // ã€ç¬¬ä¸€é é ‚ç«¯é›œè¨Šæ©¡çš®æ“¦ã€‘ï¼šå‰”é™¤ç¬¬ä¸€é é ‚éƒ¨æ¨™é¡Œã€æˆç¸¾æ¬„ç­‰é›œè¨Š
            let page1Chars = allChars.filter(c => c.pageIndex === 1);
            page1Chars.sort((a, b) => {
                const topDiff = a.top - b.top;
                if (Math.abs(topDiff) > 10) return topDiff;
                return a.left - b.left;
            });
            let p1Text = page1Chars.map(c => c.char).join('');
            
            // æ›´ç©©å¥åœ°å°‹æ‰¾ç¬¬ä¸€å¤§é¡Œçš„é–‹é ­ï¼ˆä¾‹å¦‚ï¼šä¸€ã€ / äºŒã€ï¼‰ï¼Œå®¹è¨±ç©ºæ ¼å­˜åœ¨
            let firstQMatch = p1Text.match(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\s*ã€/);
            let cutoffTop = 280; 
            if (firstQMatch) {
                let matchIdx = p1Text.indexOf(firstQMatch[0]);
                if (matchIdx !== -1 && page1Chars[matchIdx]) {
                    cutoffTop = page1Chars[matchIdx].top;
                }
            }
            
            allChars = allChars.filter(c => !(c.pageIndex === 1 && c.top < cutoffTop - 15));

            // ã€ç‰©ç†åº§æ¨™å¼·åˆ¶åˆ‡åˆ†æ³•ã€‘
            allChars.forEach(c => {
                c.col = c.left < c.pageMidX ? 0 : 1; 
            });

            // çµ‚æ¥µé–±è®€æ’åºï¼šé ç¢¼ -> å·¦å³æ¬„ä½ -> ç”±ä¸Šåˆ°ä¸‹ -> ç”±å·¦åˆ°å³
            allChars.sort((a, b) => {
                if (a.pageIndex !== b.pageIndex) return a.pageIndex - b.pageIndex;
                if (a.col !== b.col) return a.col - b.col; 
                const topDiff = a.top - b.top;
                if (Math.abs(topDiff) > 15) return topDiff; 
                return a.left - b.left; 
            });

            autoGenerateQuestionsAndDrawBoxes(allChars);
        }

        function autoGenerateQuestionsAndDrawBoxes(allChars) {
            let textWithNewlines = "";
            let charMap = []; 

            let lastC = null;
            for(let i = 0; i < allChars.length; i++) {
                let c = allChars[i];
                if (lastC) {
                    // ã€å‡ç´šã€‘ï¼šå°‡æ›è¡Œåˆ¤å®šæ›´éˆæ•åŒ– (å¾ >15 é™ç‚º >8)ï¼Œç¢ºä¿é‡åˆ°è¡Œè·è¼ƒå°æ™‚ä¹Ÿèƒ½æ­£ç¢ºæ–·è¡Œ
                    if (c.pageIndex !== lastC.pageIndex || c.col !== lastC.col || Math.abs(c.top - lastC.top) > 8) {
                        textWithNewlines += "\n";
                        charMap.push(null);
                    }
                }
                textWithNewlines += c.char;
                charMap.push(c);
                lastC = c;
            }

            // ã€å‡ç´šé¡Œè™Ÿæ•ç²ã€‘ï¼šåŠ å¼·å°ã€Œå››ã€ã€é€™é¡é–‹é ­çš„è¾¨è­˜ï¼Œå…è¨±å‰æ–¹æœ‰æ¨™é»ç¬¦è™Ÿæˆ–ç©ºç™½
            const regex = /(?:^|[\n\sã€‚ï¼ï¼Ÿ.ã€ï¼š,ï¼Œ])([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\s*ã€|\([ \u3000]*\)\s*\d+\.|\d+\.\s*|\([\d]+\)\s*|ï¼ˆ[\d]+ï¼‰\s*)/g;
            let matchIndices = [];
            let match;
            while ((match = regex.exec(textWithNewlines)) !== null) {
                let prefixStart = match.index + match[0].lastIndexOf(match[1]);
                matchIndices.push(prefixStart);
            }

            let foundQuestions = [];

            for (let i = 0; i < matchIndices.length; i++) {
                let start = matchIndices[i];
                let end = (i + 1 < matchIndices.length) ? matchIndices[i+1] - 1 : textWithNewlines.length - 1;
                let qObj = createQuestionObj(start, end, charMap, allChars);
                if (qObj) foundQuestions.push(qObj);
            }

            drawBoxesFromDynamicQuestions(foundQuestions, allChars);
        }

        function createQuestionObj(startStrIdx, endStrIdx, charMap, allChars) {
            let s = startStrIdx;
            while(s <= endStrIdx && charMap[s] === null) s++;
            if (s > endStrIdx) return null;
            let startIdx = allChars.indexOf(charMap[s]);

            let e = endStrIdx;
            while(e >= startStrIdx && charMap[e] === null) e--;
            if (e < startStrIdx) return null;
            let endIdx = allChars.indexOf(charMap[e]);

            if (startIdx === -1 || endIdx === -1) return null;

            let qText = "";
            for(let k = startIdx; k <= endIdx; k++) {
                qText += allChars[k].char;
            }

            // ã€å¤§é¡Œé …åˆ¤å®šã€‘ï¼šåˆ¤æ–·é€™ä¸€æ®µæ˜¯å¦ç‚ºåœ‹å­—æ•¸å­—é–‹é ­çš„å¤§é¡Œé …ï¼ˆä¸€ã€äºŒã€å››ã€ç­‰ï¼‰
            let isMainSection = /^[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\s*ã€/.test(qText.trim());

            return {
                text: qText,
                startIndex: startIdx,
                endIndex: endIdx,
                isMainSection: isMainSection,
                boxes: []
            };
        }

        function drawBoxesFromDynamicQuestions(foundQuestions, allChars) {
            foundQuestions.forEach(q => {
                let chars = [];
                for (let i = q.startIndex; i <= q.endIndex; i++) chars.push(allChars[i]);
                if (chars.length === 0) return;

                let charsByLayer = new Map();
                chars.forEach(c => {
                    if (!charsByLayer.has(c.layer)) charsByLayer.set(c.layer, []);
                    charsByLayer.get(c.layer).push(c);
                });

                charsByLayer.forEach((layerChars, layer) => {
                    
                    if (q.isMainSection) {
                        // ã€å¤§é¡Œé …å°ˆå±¬è™•ç†ã€‘ï¼šè§£é™¤ä¸­ç·šé™åˆ¶ï¼å°‡æ•´å€‹å¤§æ¨™é¡Œé …åŒ…è¦†åœ¨å–®ä¸€ã€ç¨ç«‹ä¸”ä¸å—æ¬„ä½åˆ‡å‰²çš„å¤§ç´…æ¡†ä¸­
                        let minL = Math.min(...layerChars.map(c => c.left));
                        let minT = Math.min(...layerChars.map(c => c.top));
                        let maxR = Math.max(...layerChars.map(c => c.left + c.width));
                        let maxB = Math.max(...layerChars.map(c => c.top + c.height));
                        
                        let boxWidth = maxR - minL;
                        if (boxWidth <= 0) return;

                        const paddingX = 4;
                        const paddingY = 1; 
                        const paddingRight = 8; 
                        
                        const box = document.createElement('div');
                        box.className = 'q-box main-section-box';
                        // åŠ ç²—é‚Šæ¡†èˆ‡æ›´é¡¯çœ¼çš„æ¨£å¼ï¼Œä»¥å€åˆ¥é€™æ˜¯ä¸€å€‹å¤§é¡Œé …
                        box.style.borderWidth = '3px'; 
                        box.style.left = (minL - paddingX) + 'px';
                        box.style.top = (minT - paddingY) + 'px';
                        box.style.width = (boxWidth + paddingX + paddingRight) + 'px';
                        box.style.height = (maxB - minT + paddingY * 2) + 'px';
                        
                        const progressContainer = document.createElement('div');
                        progressContainer.className = 'progress-container';
                        const progressBar = document.createElement('div');
                        progressBar.className = 'progress-bar';
                        progressContainer.appendChild(progressBar);
                        box.appendChild(progressContainer);

                        box.onclick = () => readText(q.text, q.boxes);
                        layer.appendChild(box);
                        q.boxes.push(box);

                    } else {
                        // ã€ä¸€èˆ¬é¡Œç›®è™•ç†ã€‘ï¼šåš´æ ¼å¥—ç”¨å·¦å³æ¬„ä¸­ç·šç‰©ç†éš”é›¢
                        const charsByCol = { '-1': [], 0: [], 1: [] };
                        layerChars.forEach(c => {
                            if (!charsByCol[c.col]) charsByCol[c.col] = [];
                            charsByCol[c.col].push(c);
                        });

                        Object.keys(charsByCol).forEach(colKey => {
                            const col = parseInt(colKey);
                            const validChars = charsByCol[col];
                            
                            if (validChars.length === 0) return;
                            if (col !== -1 && validChars.length < 2) return; 

                            let minL = Math.min(...validChars.map(c => c.left));
                            let minT = Math.min(...validChars.map(c => c.top));
                            let maxR = Math.max(...validChars.map(c => c.left + c.width));
                            let maxB = Math.max(...validChars.map(c => c.top + c.height));
                            let midX = validChars[0].pageMidX;
                            
                            let finalLeft = minL;
                            let finalRight = maxR;

                            if (col === 0) {
                                finalRight = Math.min(finalRight, midX - 2); 
                            } else if (col === 1) {
                                finalLeft = Math.max(finalLeft, midX + 2); 
                            }
                            
                            let boxWidth = finalRight - finalLeft;
                            if (boxWidth <= 0) return;

                            const paddingX = 4;
                            const paddingY = 1; 
                            const paddingRight = 8; 
                            
                            const box = document.createElement('div');
                            box.className = 'q-box';
                            box.style.left = (finalLeft - paddingX) + 'px';
                            box.style.top = (minT - paddingY) + 'px';
                            box.style.width = (boxWidth + paddingX + paddingRight) + 'px';
                            box.style.height = (maxB - minT + paddingY * 2) + 'px';
                            
                            const progressContainer = document.createElement('div');
                            progressContainer.className = 'progress-container';
                            const progressBar = document.createElement('div');
                            progressBar.className = 'progress-bar';
                            progressContainer.appendChild(progressBar);
                            box.appendChild(progressContainer);

                            box.onclick = () => readText(q.text, q.boxes);
                            layer.appendChild(box);
                            q.boxes.push(box);
                        });
                    }
                });
            });
            
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('pdf-viewer').style.opacity = '1';
            
            if (foundQuestions.length === 0) {
                document.getElementById('status-text').innerText = "âš ï¸ è§£æå¤±æ•—ï¼Œè«‹ç¢ºèªä¸Šå‚³çš„ PDF æ˜¯å¦åŒ…å«å¯é¸å–çš„æ–‡å­—ã€‚";
                document.getElementById('status-text').style.color = "#e74c3c";
            } else {
                document.getElementById('status-text').innerText = `âœ… è§£æå®Œæˆï¼å·²å®Œç¾éš”é›¢ã€Œå¤§é¡Œé …æ¨™é¡Œã€èˆ‡ã€Œç¨ç«‹é¡Œç›®ã€ã€‚`;
                document.getElementById('status-text').style.color = "#27ae60";
            }
        }

        // ==========================================
        // èªéŸ³å ±è®€ã€æ™ºæ…§æ–·å¥åœé “èˆ‡é€²åº¦æ¢æ§åˆ¶
        // ==========================================
        const synth = window.speechSynthesis;
        let currentUtterance = null;
        let currentActiveBoxes = []; 

        const btnPause = document.getElementById('btnPause');
        const btnResume = document.getElementById('btnResume');
        const btnStop = document.getElementById('btnStop');
        const speedInput = document.getElementById('speedRate');
        
        speedInput.addEventListener('input', e => { document.getElementById('speedValue').innerText = e.target.value; });

        function updateButtonsState(isPlaying, isPaused) {
            btnPause.disabled = !isPlaying || isPaused;
            btnResume.disabled = !isPaused;
            btnStop.disabled = !isPlaying && !isPaused;
        }

        function clearHighlights() {
            if (currentActiveBoxes && currentActiveBoxes.length > 0) {
                currentActiveBoxes.forEach(box => {
                    box.classList.remove('reading', 'paused');
                    let pb = box.querySelector('.progress-bar');
                    if (pb) pb.style.width = '0%';
                });
            }
        }

        let chunkQueue = [];
        let currentChunkIndex = 0;
        let isReadingStopped = true;
        let isReadingProcessPaused = false;
        let isWaitingInGap = false;
        let pauseTimeout = null;

        let currentSpeakText = "";
        let pausedCharIndex = 0;
        let isResumingFromPause = false;
        let baseCharIndex = 0;

        function readText(textToRead, boxElementsArray) {
            if (currentActiveBoxes === boxElementsArray && isReadingProcessPaused) {
                resumeReading();
                return;
            }

            stopReading(); 
            isReadingStopped = false;
            isResumingFromPause = false;
            pausedCharIndex = 0;
            currentActiveBoxes = boxElementsArray;

            const regex = /((?:\([ \u3000]*\)[\s]*)?\d+\.\s*|[â‘ -â‘³]\s*|\(\d+\)\s*)/g;
            chunkQueue = [];
            let lastIndex = 0;
            let match;
            let cumulativeLength = 0;

            while ((match = regex.exec(textToRead)) !== null) {
                if (match.index > lastIndex) {
                    let txt = textToRead.substring(lastIndex, match.index);
                    chunkQueue.push({ text: txt, isNumber: false, startIdx: cumulativeLength, length: txt.length });
                    cumulativeLength += txt.length;
                }
                let numTxt = match[0];
                chunkQueue.push({ text: numTxt, isNumber: true, startIdx: cumulativeLength, length: numTxt.length });
                cumulativeLength += numTxt.length;
                lastIndex = regex.lastIndex;
            }
            if (lastIndex < textToRead.length) {
                let txt = textToRead.substring(lastIndex);
                chunkQueue.push({ text: txt, isNumber: false, startIdx: cumulativeLength, length: txt.length });
            }

            currentChunkIndex = 0;
            playNextChunk();
        }

        function playNextChunk() {
            if (isReadingStopped) return;

            while (currentChunkIndex < chunkQueue.length && chunkQueue[currentChunkIndex].text.trim() === '') {
                let chunk = chunkQueue[currentChunkIndex];
                updateProgressBar(chunk.startIdx + chunk.length);
                currentChunkIndex++;
            }

            if (currentChunkIndex >= chunkQueue.length) {
                updateProgressBar(Number.MAX_SAFE_INTEGER); 
                setTimeout(() => {
                    if (!isReadingStopped) {
                        clearHighlights();
                        currentActiveBoxes = [];
                        updateButtonsState(false, false);
                        isReadingStopped = true;
                    }
                }, 500);
                return;
            }

            let chunk = chunkQueue[currentChunkIndex];
            
            let isOptionBullet = /[â‘ -â‘³]/.test(chunk.text);
            if (isOptionBullet && chunk._hasPreDelayed !== true && !isResumingFromPause) {
                isWaitingInGap = true;
                chunk._hasPreDelayed = true; 
                pauseTimeout = setTimeout(() => {
                    if (isReadingStopped) return;
                    if (!isReadingProcessPaused) {
                        isWaitingInGap = false;
                        playNextChunk(); 
                    }
                }, 1000);
                return;
            }

            isWaitingInGap = false;

            if (!isResumingFromPause) {
                let speakText = chunk.text
                    .replace(/[ï¼-ï¼™]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xFEE0)) 
                    .replace(/(\d+)\./g, '$1ã€') 
                    .replace(/(?<!\d)(\d{1,2})(?!\d)/g, (match) => { 
                        const n = parseInt(match, 10);
                        if (n === 10) return 'å';
                        if (n > 10 && n < 20) return 'å' + (n - 10);
                        if (n >= 20 && n % 10 === 0) return Math.floor(n / 10) + 'å';
                        if (n > 20) return Math.floor(n / 10) + 'å' + (n % 10);
                        return match; 
                    })
                    .replace(/æ‰“[vVï½–ï¼¶Ë‡]/g, 'æ‰“å‹¾')
                    .replace(/Ë‡/g, 'æ‰“å‹¾')
                    .replace(/[ï‚£â˜]/g, 'æ–¹æ¡†')
                    .replace(/å£(?=ä¸­æ‰“)/g, 'æ–¹æ¡†')
                    .replace(/â‘ /g, 'ä¸€ã€')
                    .replace(/â‘¡/g, 'äºŒã€')
                    .replace(/â‘¢/g, 'ä¸‰ã€')
                    .replace(/â‘£/g, 'å››ã€')
                    .replace(/â‘¤/g, 'äº”ã€')
                    .replace(/â‘¥/g, 'å…­ã€')
                    .replace(/ã„…/g, 'æ³¢ã€')
                    .replace(/ã„†/g, 'å¡ã€')
                    .replace(/ã„‡/g, 'æ‘¸ã€')
                    .replace(/ã„ˆ/g, 'ä½›ã€')
                    .replace(/ã„‰/g, 'å¾—ã€')
                    .replace(/ã„Š/g, 'ç‰¹ã€');

                currentSpeakText = speakText;
                pausedCharIndex = 0;
            }

            let textToSpeak = currentSpeakText.substring(pausedCharIndex);
            baseCharIndex = pausedCharIndex; 

            currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
            currentUtterance.lang = 'zh-TW';
            currentUtterance.rate = parseFloat(speedInput.value);

            currentUtterance.onstart = () => {
                isWaitingInGap = false;
                if (!currentActiveBoxes[0]?.classList.contains('reading')) {
                    currentActiveBoxes.forEach(box => {
                        box.classList.add('reading');
                        box.classList.remove('paused');
                    });
                    updateButtonsState(true, false);
                }
            };

            currentUtterance.onboundary = (event) => {
                if (isReadingStopped) return;
                pausedCharIndex = baseCharIndex + event.charIndex; 
                let progressRatio = currentSpeakText.length > 0 ? (pausedCharIndex / currentSpeakText.length) : 0;
                let currentGlobalIdx = chunk.startIdx + Math.floor(chunk.length * progressRatio);
                updateProgressBar(currentGlobalIdx);
            };

            currentUtterance.onend = () => {
                if (isReadingStopped || isReadingProcessPaused) return; 

                updateProgressBar(chunk.startIdx + chunk.length); 
                currentChunkIndex++;
                isResumingFromPause = false;
                pausedCharIndex = 0;
                
                if (chunk.isNumber) {
                    isWaitingInGap = true;
                    pauseTimeout = setTimeout(() => {
                        if (isReadingStopped) return;
                        if (!isReadingProcessPaused) {
                            playNextChunk(); 
                        }
                    }, 500);
                } else {
                    playNextChunk(); 
                }
            };

            currentUtterance.onerror = (e) => {
                if (e.error !== 'canceled' && !isReadingStopped) {
                    currentChunkIndex++;
                    isResumingFromPause = false;
                    pausedCharIndex = 0;
                    playNextChunk();
                }
            };

            if (!isReadingProcessPaused) {
                synth.speak(currentUtterance);
            }
        }

        function updateProgressBar(currentGlobalIdx) {
            if (chunkQueue.length === 0) return;
            let lastChunk = chunkQueue[chunkQueue.length - 1];
            let totalLength = lastChunk.startIdx + lastChunk.length;
            let percentage = totalLength === 0 ? 100 : (currentGlobalIdx / totalLength) * 100;
            if (percentage > 100) percentage = 100;
            currentActiveBoxes.forEach(box => {
                let pb = box.querySelector('.progress-bar');
                if (pb) pb.style.width = percentage + '%';
            });
        }

        function pauseReading() {
            if (currentActiveBoxes.length > 0 && !isReadingProcessPaused && !isReadingStopped) {
                isReadingProcessPaused = true;
                if (!isWaitingInGap) {
                    synth.cancel(); 
                } else {
                    clearTimeout(pauseTimeout); 
                }
                currentActiveBoxes.forEach(box => {
                    box.classList.remove('reading');
                    box.classList.add('paused');
                });
                updateButtonsState(true, true);
            }
        }

        function resumeReading() {
            if (isReadingProcessPaused) {
                isReadingProcessPaused = false;
                
                if (isWaitingInGap) {
                    isWaitingInGap = false;
                    playNextChunk(); 
                } else {
                    isResumingFromPause = true;
                    playNextChunk(); 
                }

                currentActiveBoxes.forEach(box => {
                    box.classList.remove('paused');
                    box.classList.add('reading');
                });
                updateButtonsState(true, false);
            }
        }

        function stopReading() {
            isReadingStopped = true;
            isReadingProcessPaused = false;
            clearTimeout(pauseTimeout);
            synth.cancel();
            clearHighlights();
            currentActiveBoxes = [];
            updateButtonsState(false, false);
            isResumingFromPause = false;
            pausedCharIndex = 0;
        }

        window.onbeforeunload = () => synth.cancel();
    </script>
</body>
</html>