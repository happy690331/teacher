<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›´å¼é›™æ¬„å ±è®€ç³»çµ±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body {
            font-family: "Microsoft JhengHei", sans-serif;
            background-color: #2c3e50;
            color: #333;
            margin: 0;
            padding: 0;
            padding-bottom: 60px;
        }

        #control-panel {
            position: sticky;
            top: 0;
            background-color: #ffffff;
            padding: 15px 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }

        .title-area h1 { margin: 0; font-size: 20px; color: #2c3e50; font-weight: bold; }
        .title-area p { margin: 5px 0 0 0; font-size: 14px; color: #7f8c8d; }

        .controls { display: flex; align-items: center; gap: 10px; }
        button {
            background-color: #3498db; color: white; border: none;
            padding: 8px 12px; border-radius: 6px; font-size: 15px;
            cursor: pointer; font-weight: bold; transition: all 0.2s;
        }
        button:hover { background-color: #2980b9; }
        button.btn-stop { background-color: #e74c3c; }
        button.btn-pause { background-color: #f39c12; }
        button.btn-resume { background-color: #2ecc71; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        
        /* æ–°å¢é‡æ–°é¸æ“‡æŒ‰éˆ•æ¨£å¼ï¼šå¼·åˆ¶æ‹‰é–‹èˆ‡å·¦é‚Š(åœæ­¢éµ)çš„è·é›¢ï¼Œæ¨åˆ°æœ€å³é‚Š */
        button.btn-reset { 
            background-color: #9b59b6; 
            margin-left: 80px; /* å¢åŠ  80px çš„è¶…å¤§å®‰å…¨è·é›¢ (æ‹‰é–‹å…©å€) */
        }
        button.btn-reset:hover { background-color: #8e44ad; }

        .speed-control {
            display: flex; align-items: center; gap: 8px; font-weight: bold;
            background: #f1f2f6; padding: 5px 10px; border-radius: 6px;
        }

        #upload-screen {
            display: flex; flex-direction: row; flex-wrap: wrap; align-items: stretch;
            justify-content: center; min-height: 70vh; color: white; gap: 30px;
            padding: 40px 20px; box-sizing: border-box;
        }
        .upload-box {
            background: rgba(255,255,255,0.1); padding: 40px 30px; border-radius: 12px;
            text-align: center; border: 2px dashed #ecf0f1; flex: 1; min-width: 300px; max-width: 450px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .upload-box input[type="file"] {
            margin-top: 15px; font-size: 16px; color: white; width: 100%;
        }
        .upload-box input[type="text"] {
            margin-top: 15px; font-size: 16px; padding: 8px; width: 70%; border-radius: 4px; border: none;
        }
        .upload-box button.fetch-btn {
            margin-top: 15px; background-color: #e67e22; font-size: 16px;
        }
        .upload-box button.fetch-btn:hover { background-color: #d35400; }
        
        #loading-screen {
            display: none; color: white; text-align: center; margin-top: 50px; font-size: 20px;
        }

        #pdf-viewer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px auto;
            width: 100%;
            opacity: 0; 
            transition: opacity 0.5s;
        }

        .pdf-page {
            position: relative; 
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background-color: white;
        }

        .pdf-page canvas { display: block; }

        .textLayer {
            position: absolute; left: 0; top: 0; right: 0; bottom: 0;
            color: transparent; pointer-events: none; overflow: hidden;
        }
        .textLayer span {
            position: absolute; white-space: pre; transform-origin: 0% 0%;
        }

        .boxLayer {
            position: absolute; left: 0; top: 0; right: 0; bottom: 0;
            pointer-events: none; 
        }

        .q-box {
            position: absolute;
            border: 2px solid transparent; /* å°‡é è¨­é‚Šæ¡†æ”¹ç‚ºé€æ˜éš±å½¢ */
            border-radius: 4px;
            background-color: transparent; /* å°‡é è¨­èƒŒæ™¯æ”¹ç‚ºé€æ˜éš±å½¢ */
            cursor: pointer;
            pointer-events: auto; 
            transition: all 0.2s;
        }

        .q-box:hover {
            background-color: rgba(231, 76, 60, 0.15);
            border-color: rgba(231, 76, 60, 1); /* æ»‘é¼ æ¸¸æ¨™ç§»å…¥æ™‚æ‰é¡¯ç¤ºç´…è‰²é‚Šæ¡† */
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.4);
        }

        .q-box.reading {
            background-color: rgba(241, 196, 15, 0.25); 
            border-color: #e67e22;
            border-width: 3px;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.6);
            z-index: 10;
        }

        .q-box.paused {
            background-color: rgba(189, 195, 199, 0.4);
            border-style: dashed;
            border-color: #7f8c8d;
        }

        .progress-container {
            position: absolute;
            bottom: -6px; 
            left: -2px; 
            width: calc(100% + 4px);
            height: 6px;
            background-color: #ecf0f1;
            border-radius: 2px;
            overflow: hidden;
            display: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .q-box.reading .progress-container, 
        .q-box.paused .progress-container {
            display: block;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background-color: #2ecc71; 
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

    <div id="control-panel">
        <div class="title-area">
            <h1>ç›´å¼é›™æ¬„å ±è®€ç³»çµ±</h1>
            <p id="status-text">è«‹é¸æ“‡è¼‰å…¥æ–¹å¼ï¼šæœ¬æ©Ÿä¸Šå‚³ æˆ– GitHub é¡Œåº«ä¸‹è¼‰ã€‚</p>
        </div>
        <div class="controls">
            <div class="speed-control">
                <label for="speedRate">èªé€Ÿï¼š</label>
                <input type="range" id="speedRate" min="0.5" max="1.5" step="0.1" value="1.0">
                <span id="speedValue">1.0</span>
            </div>
            <button class="btn-pause" id="btnPause" onclick="pauseReading()" disabled>â¸ï¸ æš«åœ</button>
            <button class="btn-resume" id="btnResume" onclick="resumeReading()" disabled>â–¶ï¸ ç¹¼çºŒ</button>
            <button class="btn-stop" id="btnStop" onclick="stopReading()" disabled>â¹ï¸ åœæ­¢</button>
            <!-- æ–°å¢é‡æ–°é¸æ“‡æŒ‰éˆ• -->
            <button class="btn-reset" id="btnReset" onclick="resetSystem()">ğŸ”„ é‡æ–°é¸æ“‡</button>
        </div>
    </div>

    <div id="upload-screen">
        <div class="upload-box">
            <h2>ğŸ“ æ–¹å¼ä¸€ï¼šå¾æœ¬æ©Ÿä¸Šå‚³è€ƒå· PDF</h2>
            <p>æ”¯æ´ä»»ä½•æ¨™æº–ç›´å¼é›™æ¬„è€ƒå·</p>
            <input type="file" id="pdf-upload" accept="application/pdf">
        </div>
        <div class="upload-box">
            <h2>ğŸŒ æ–¹å¼äºŒï¼šå¾ GitHub é¡Œåº«è¼‰å…¥</h2>
            <p style="font-size: 13px; color: #bdc3c7;">ä¾†æº: happy690331/teacher/tree/main/exam paper</p>
            <button class="fetch-btn" id="btn-fetch-list" onclick="fetchGitHubList()">ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨</button>
            <select id="github-select" style="display:none; margin-top: 15px; font-size: 16px; padding: 8px; width: 90%; border-radius: 4px; border: none;"></select>
            <button class="fetch-btn" id="btn-load-selected" onclick="loadSelectedGitHub()" style="display:none; background-color: #27ae60; margin-top: 10px;">ğŸš€ è¼‰å…¥é¸æ“‡çš„è€ƒå·</button>
        </div>
    </div>
    
    <div id="loading-screen">ç³»çµ±æ­£åœ¨å•Ÿå‹•ã€Œç²¾æº–é›™æ¬„ç‰©ç†åˆ‡åˆ†ã€èˆ‡ã€ŒAIè‡ªå‹•é¡Œè™Ÿè¾¨è­˜ã€ï¼Œè«‹ç¨å€™... âš™ï¸</div>

    <div id="pdf-viewer"></div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // ==========================================
        // è¼‰å…¥é‚è¼¯ï¼šæœ¬æ©Ÿä¸Šå‚³ æˆ– GitHub ä¸‹è¼‰
        // ==========================================
        document.getElementById('pdf-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                showLoading();
                setTimeout(() => {
                    const fileReader = new FileReader();
                    fileReader.onload = function() {
                        const typedarray = new Uint8Array(this.result);
                        renderPDFAndExtractCoordinates(typedarray);
                    };
                    fileReader.readAsArrayBuffer(file);
                }, 100);
            }
        });

        async function fetchGitHubList() {
            const btnFetch = document.getElementById('btn-fetch-list');
            btnFetch.innerText = 'è®€å–æ¸…å–®ä¸­... â³';
            btnFetch.disabled = true;

            try {
                const apiUrl = "https://api.github.com/repos/happy690331/teacher/contents/exam%20paper?ref=main";
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error("ç„¡æ³•å–å¾—ç·šä¸Šæ¸…å–®");
                const data = await response.json();

                const pdfFiles = data.filter(item => item.name.toLowerCase().endsWith('.pdf'));

                if (pdfFiles.length === 0) {
                    alert("è©²è³‡æ–™å¤¾ä¸‹æ²’æœ‰æ‰¾åˆ° PDF æª”æ¡ˆï¼");
                    btnFetch.innerText = 'ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨';
                    btnFetch.disabled = false;
                    return;
                }

                const selectElement = document.getElementById('github-select');
                selectElement.innerHTML = '<option value="">-- è«‹é¸æ“‡ä¸€ä»½è€ƒå· --</option>';
                pdfFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.download_url; 
                    option.textContent = file.name;
                    selectElement.appendChild(option);
                });

                btnFetch.style.display = 'none';
                selectElement.style.display = 'block';
                document.getElementById('btn-load-selected').style.display = 'inline-block';

            } catch (error) {
                alert("ç²å–æ¸…å–®å¤±æ•—ï¼š" + error.message);
                btnFetch.innerText = 'ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨';
                btnFetch.disabled = false;
            }
        }

        async function loadSelectedGitHub() {
            const selectElement = document.getElementById('github-select');
            const fetchUrl = selectElement.value;
            
            if (!fetchUrl) {
                alert("è«‹å…ˆå¾ä¸‹æ‹‰é¸å–®é¸æ“‡ä¸€ä»½è€ƒå·ï¼");
                return;
            }

            showLoading();

            try {
                const response = await fetch(fetchUrl);
                if (!response.ok) throw new Error("æ‰¾ä¸åˆ°æª”æ¡ˆ (HTTP " + response.status + ")");
                const arrayBuffer = await response.arrayBuffer();
                const typedarray = new Uint8Array(arrayBuffer);
                renderPDFAndExtractCoordinates(typedarray);
            } catch (error) {
                alert("ç„¡æ³•å¾ GitHub è¼‰å…¥æª”æ¡ˆï¼\nè©³ç´°éŒ¯èª¤ï¼š" + error.message);
                hideLoading();
            }
        }

        function showLoading() {
            document.getElementById('upload-screen').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'block';
            document.getElementById('pdf-viewer').style.opacity = '0';
        }

        function hideLoading() {
            document.getElementById('upload-screen').style.display = 'flex';
            document.getElementById('loading-screen').style.display = 'none';
        }

        // ==========================================
        // æ ¸å¿ƒè§£æèˆ‡å‹•æ…‹é¡Œåº«ç”Ÿæˆå¼•æ“
        // ==========================================
        async function renderPDFAndExtractCoordinates(pdfData) {
            const pdf = await pdfjsLib.getDocument(pdfData).promise;
            const viewer = document.getElementById('pdf-viewer');
            viewer.innerHTML = '';
            
            let allChars = []; 

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 2.0 });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.style.width = viewport.width + 'px';
                pageDiv.style.height = viewport.height + 'px';
                
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                pageDiv.appendChild(canvas);
                
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'textLayer';
                pageDiv.appendChild(textLayerDiv);
                
                const boxLayerDiv = document.createElement('div');
                boxLayerDiv.className = 'boxLayer';
                pageDiv.appendChild(boxLayerDiv);

                viewer.appendChild(pageDiv);

                await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;

                const textContent = await page.getTextContent();
                await pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                }).promise;

                const spans = textLayerDiv.querySelectorAll('span');
                const pageRect = pageDiv.getBoundingClientRect();

                spans.forEach(span => {
                    const text = span.textContent;
                    if (!text.trim()) return;

                    const rect = span.getBoundingClientRect();
                    const spanLeft = rect.left - pageRect.left;
                    const spanTop = rect.top - pageRect.top;
                    const charWidth = rect.width / text.length;
                    
                    for (let i = 0; i < text.length; i++) {
                        let char = text[i];
                        
                        // ã€é‡è¦ä¿®å¾©ã€‘ï¼šå°‡å…¨å½¢æ•¸å­—èˆ‡å…¨å½¢å°æ•¸é»è½‰ç‚ºåŠå½¢ï¼Œç¢ºä¿é¡Œè™Ÿèƒ½è¢«ç²¾æº–è¾¨è­˜
                        if (char >= 'ï¼' && char <= 'ï¼™') {
                            char = String.fromCharCode(char.charCodeAt(0) - 0xFEE0);
                        } else if (char === 'ï¼') {
                            char = '.';
                        }

                        // ã€é‡è¦ä¿®å¾©ã€‘ï¼šç¢ºä¿åº•ç·š _ ä¹Ÿèƒ½é€šéï¼Œå› ç‚ºè€ƒå·å¸¸å‡ºç¾ (___) 1. çš„é¡Œè™Ÿæ ¼å¼
                        let sanitized = char.replace(/[^\u4e00-\u9fa5a-zA-Z0-9\u2000-\u2BFF\u3000-\u303F\u3105-\u312F\uF000-\uF8FF\(\)ï¼ˆï¼‰\.\?ã€‚ï¼ŸË‡ï¼š:,ï¼Œï¼›!ï¼_]/g, '');
                        if (sanitized) {
                            allChars.push({
                                char: char,
                                layer: boxLayerDiv,
                                left: spanLeft + (i * charWidth),
                                top: spanTop,
                                width: charWidth,
                                height: rect.height,
                                pageIndex: pageNum,
                                pageMidX: viewport.width / 2 
                            });
                        }
                    }
                });
            }

            let page1Chars = allChars.filter(c => c.pageIndex === 1);
            page1Chars.sort((a, b) => {
                const topDiff = a.top - b.top;
                if (Math.abs(topDiff) > 10) return topDiff;
                return a.left - b.left;
            });
            let p1Text = page1Chars.map(c => c.char).join('');
            
            let firstQMatch = p1Text.match(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\s*ã€/);
            let cutoffTop = 280; 
            if (firstQMatch) {
                let matchIdx = p1Text.indexOf(firstQMatch[0]);
                if (matchIdx !== -1 && page1Chars[matchIdx]) {
                    cutoffTop = page1Chars[matchIdx].top;
                }
            }
            
            allChars = allChars.filter(c => !(c.pageIndex === 1 && c.top < cutoffTop - 15));

            allChars.forEach(c => {
                c.col = c.left < c.pageMidX ? 0 : 1; 
            });

            allChars.sort((a, b) => {
                if (a.pageIndex !== b.pageIndex) return a.pageIndex - b.pageIndex;
                if (a.col !== b.col) return a.col - b.col; 
                const topDiff = a.top - b.top;
                if (Math.abs(topDiff) > 15) return topDiff; 
                return a.left - b.left; 
            });

            autoGenerateQuestionsAndDrawBoxes(allChars);
        }

        function autoGenerateQuestionsAndDrawBoxes(allChars) {
            let textWithNewlines = "";
            let charMap = []; 

            let lastC = null;
            for(let i = 0; i < allChars.length; i++) {
                let c = allChars[i];
                if (lastC) {
                    if (c.pageIndex !== lastC.pageIndex || c.col !== lastC.col || Math.abs(c.top - lastC.top) > 8) {
                        textWithNewlines += "\n";
                        charMap.push(null);
                    }
                }
                textWithNewlines += c.char;
                charMap.push(c);
                lastC = c;
            }

            // ã€çµ‚æ¥µé¡Œè™Ÿæ•ç²ä¿®å¾©ã€‘ï¼šåŠ å¼·å°ã€Œ1ã€ã€ã€ã€Œ1ï¼ã€ã€ã€Œ( ) 1.ã€ç­‰å„å¼åœ‹å°è€ƒå·é¡Œè™Ÿçš„è¾¨è­˜
            // è§£æ±ºæ•´é è¢«ç•¶æˆå–®ä¸€é¡Œç›®çš„å•é¡Œ (å› ç‚ºåŸæœ¬çš„æ­£è¦è¡¨é”å¼æŠ“ä¸åˆ° 1ã€ é€™ç¨®é¡Œè™Ÿæ ¼å¼)
            const regex = /(?:^|[\n\sã€‚ï¼ï¼Ÿ.ã€ï¼š,ï¼Œ])([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\s*ã€|(?:[\(ï¼ˆ][ \u3000_]*[\)ï¼‰]\s*)?\d+\s*[\.ï¼ã€]\s*|[\(ï¼ˆ]\s*\d+\s*[\)ï¼‰]\s*)/g;
            let matchIndices = [];
            let match;
            while ((match = regex.exec(textWithNewlines)) !== null) {
                let prefixStart = match.index + match[0].lastIndexOf(match[1]);
                matchIndices.push(prefixStart);
            }

            let foundQuestions = [];

            for (let i = 0; i < matchIndices.length; i++) {
                let start = matchIndices[i];
                let end = (i + 1 < matchIndices.length) ? matchIndices[i+1] - 1 : textWithNewlines.length - 1;
                let qObj = createQuestionObj(start, end, charMap, allChars);
                if (qObj) foundQuestions.push(qObj);
            }

            drawBoxesFromDynamicQuestions(foundQuestions, allChars);
        }

        function createQuestionObj(startStrIdx, endStrIdx, charMap, allChars) {
            let s = startStrIdx;
            while(s <= endStrIdx && charMap[s] === null) s++;
            if (s > endStrIdx) return null;
            let startIdx = allChars.indexOf(charMap[s]);

            let e = endStrIdx;
            while(e >= startStrIdx && charMap[e] === null) e--;
            if (e < startStrIdx) return null;
            let endIdx = allChars.indexOf(charMap[e]);

            if (startIdx === -1 || endIdx === -1) return null;

            let qText = "";
            for(let k = startIdx; k <= endIdx; k++) {
                qText += allChars[k].char;
            }

            let isMainSection = /^[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+\s*ã€/.test(qText.trim());

            return {
                text: qText,
                startIndex: startIdx,
                endIndex: endIdx,
                isMainSection: isMainSection,
                boxes: []
            };
        }

        function drawBoxesFromDynamicQuestions(foundQuestions, allChars) {
            foundQuestions.forEach(q => {
                let chars = [];
                for (let i = q.startIndex; i <= q.endIndex; i++) chars.push(allChars[i]);
                if (chars.length === 0) return;

                let charsByLayer = new Map();
                chars.forEach(c => {
                    if (!charsByLayer.has(c.layer)) charsByLayer.set(c.layer, []);
                    charsByLayer.get(c.layer).push(c);
                });

                charsByLayer.forEach((layerChars, layer) => {
                    
                    if (q.isMainSection) {
                        let minL = Math.min(...layerChars.map(c => c.left));
                        let minT = Math.min(...layerChars.map(c => c.top));
                        let maxR = Math.max(...layerChars.map(c => c.left + c.width));
                        let maxB = Math.max(...layerChars.map(c => c.top + c.height));
                        
                        let boxWidth = maxR - minL;
                        if (boxWidth <= 0) return;

                        const paddingX = 4;
                        const paddingY = 1; 
                        const paddingRight = 8; 
                        
                        const box = document.createElement('div');
                        box.className = 'q-box main-section-box';
                        box.style.borderWidth = '3px'; 
                        box.style.left = (minL - paddingX) + 'px';
                        box.style.top = (minT - paddingY) + 'px';
                        box.style.width = (boxWidth + paddingX + paddingRight) + 'px';
                        box.style.height = (maxB - minT + paddingY * 2) + 'px';
                        
                        const progressContainer = document.createElement('div');
                        progressContainer.className = 'progress-container';
                        const progressBar = document.createElement('div');
                        progressBar.className = 'progress-bar';
                        progressContainer.appendChild(progressBar);
                        box.appendChild(progressContainer);

                        box.onclick = () => readText(q.text, q.boxes);
                        layer.appendChild(box);
                        q.boxes.push(box);

                    } else {
                        const charsByCol = { '-1': [], 0: [], 1: [] };
                        layerChars.forEach(c => {
                            if (!charsByCol[c.col]) charsByCol[c.col] = [];
                            charsByCol[c.col].push(c);
                        });

                        Object.keys(charsByCol).forEach(colKey => {
                            const col = parseInt(colKey);
                            const validChars = charsByCol[col];
                            
                            if (validChars.length === 0) return;
                            if (col !== -1 && validChars.length < 2) return; 

                            let minL = Math.min(...validChars.map(c => c.left));
                            let minT = Math.min(...validChars.map(c => c.top));
                            let maxR = Math.max(...validChars.map(c => c.left + c.width));
                            let maxB = Math.max(...validChars.map(c => c.top + c.height));
                            let midX = validChars[0].pageMidX;
                            
                            let finalLeft = minL;
                            let finalRight = maxR;

                            if (col === 0) {
                                finalRight = Math.min(finalRight, midX - 2); 
                            } else if (col === 1) {
                                finalLeft = Math.max(finalLeft, midX + 2); 
                            }
                            
                            let boxWidth = finalRight - finalLeft;
                            if (boxWidth <= 0) return;

                            const paddingX = 4;
                            const paddingY = 1; 
                            const paddingRight = 8; 
                            
                            const box = document.createElement('div');
                            box.className = 'q-box';
                            box.style.left = (finalLeft - paddingX) + 'px';
                            box.style.top = (minT - paddingY) + 'px';
                            box.style.width = (boxWidth + paddingX + paddingRight) + 'px';
                            box.style.height = (maxB - minT + paddingY * 2) + 'px';
                            
                            const progressContainer = document.createElement('div');
                            progressContainer.className = 'progress-container';
                            const progressBar = document.createElement('div');
                            progressBar.className = 'progress-bar';
                            progressContainer.appendChild(progressBar);
                            box.appendChild(progressContainer);

                            box.onclick = () => readText(q.text, q.boxes);
                            layer.appendChild(box);
                            q.boxes.push(box);
                        });
                    }
                });
            });
            
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('pdf-viewer').style.opacity = '1';
            
            if (foundQuestions.length === 0) {
                document.getElementById('status-text').innerText = "âš ï¸ è§£æå¤±æ•—ï¼Œè«‹ç¢ºèªä¸Šå‚³çš„ PDF æ˜¯å¦åŒ…å«å¯é¸å–çš„æ–‡å­—ã€‚";
                document.getElementById('status-text').style.color = "#e74c3c";
            } else {
                document.getElementById('status-text').innerText = `âœ… è§£æå®Œæˆï¼å·²å®Œç¾éš”é›¢ã€Œå¤§é¡Œé …æ¨™é¡Œã€èˆ‡ã€Œç¨ç«‹é¡Œç›®ã€ã€‚`;
                document.getElementById('status-text').style.color = "#27ae60";
            }
        }

        // ==========================================
        // èªéŸ³å ±è®€ã€æ™ºæ…§æ–·å¥åœé “èˆ‡é€²åº¦æ¢æ§åˆ¶
        // ==========================================
        const synth = window.speechSynthesis;
        let currentUtterance = null;
        let currentActiveBoxes = []; 

        const btnPause = document.getElementById('btnPause');
        const btnResume = document.getElementById('btnResume');
        const btnStop = document.getElementById('btnStop');
        const speedInput = document.getElementById('speedRate');
        
        speedInput.addEventListener('input', e => { document.getElementById('speedValue').innerText = e.target.value; });

        function updateButtonsState(isPlaying, isPaused) {
            btnPause.disabled = !isPlaying || isPaused;
            btnResume.disabled = !isPaused;
            btnStop.disabled = !isPlaying && !isPaused;
        }

        function clearHighlights() {
            if (currentActiveBoxes && currentActiveBoxes.length > 0) {
                currentActiveBoxes.forEach(box => {
                    box.classList.remove('reading', 'paused');
                    let pb = box.querySelector('.progress-bar');
                    if (pb) pb.style.width = '0%';
                });
            }
        }

        let chunkQueue = [];
        let currentChunkIndex = 0;
        let isReadingStopped = true;
        let isReadingProcessPaused = false;
        let isWaitingInGap = false;
        let pauseTimeout = null;

        let currentSpeakText = "";
        let pausedCharIndex = 0;
        let isResumingFromPause = false;
        let baseCharIndex = 0;
        
        let currentOriginalText = "";

        function readText(textToRead, boxElementsArray) {
            if (currentActiveBoxes === boxElementsArray && isReadingProcessPaused) {
                resumeReading();
                return;
            }

            stopReading(); 
            isReadingStopped = false;
            isResumingFromPause = false;
            pausedCharIndex = 0;
            currentActiveBoxes = boxElementsArray;
            currentOriginalText = textToRead;

            // ã€åŒæ­¥å‡ç´šã€‘ï¼šè®“èªéŸ³åˆ†æ®µå¼•æ“ä¹Ÿèƒ½èªå¾—ã€Œ1ã€ã€ã€ã€Œ( ) 1.ã€ç­‰æ ¼å¼
            const regex = /((?:[\(ï¼ˆ][ \u3000_]*[\)ï¼‰]\s*)?\d+\s*[\.ï¼ã€]\s*|[â‘ -â‘³]\s*|[\(ï¼ˆ]\s*\d+\s*[\)ï¼‰]\s*|[â–¡ï‚£â˜])/g;
            chunkQueue = [];
            let lastIndex = 0;
            let match;
            let cumulativeLength = 0;

            while ((match = regex.exec(textToRead)) !== null) {
                if (match.index > lastIndex) {
                    let txt = textToRead.substring(lastIndex, match.index);
                    chunkQueue.push({ text: txt, isNumber: false, startIdx: cumulativeLength, length: txt.length });
                    cumulativeLength += txt.length;
                }
                let numTxt = match[0];
                let isNumSign = !/[â–¡ï‚£â˜]/.test(numTxt);
                chunkQueue.push({ text: numTxt, isNumber: isNumSign, startIdx: cumulativeLength, length: numTxt.length });
                cumulativeLength += numTxt.length;
                lastIndex = regex.lastIndex;
            }
            if (lastIndex < textToRead.length) {
                let txt = textToRead.substring(lastIndex);
                chunkQueue.push({ text: txt, isNumber: false, startIdx: cumulativeLength, length: txt.length });
            }

            currentChunkIndex = 0;

            // ã€æ ¸å¿ƒä¿®å¾©ã€‘ï¼šç«‹åˆ»å¼·åˆ¶è§£é–æŒ‰éˆ•èˆ‡ UI ç‹€æ…‹ï¼
            // ç¶²é ç‰ˆç’°å¢ƒä¸‹ï¼ŒèªéŸ³å¼•æ“çš„ onstart äº‹ä»¶æœ‰æ™‚æœƒå»¶é²æˆ–å¤±æ•ˆï¼Œ
            // å°‡è§£é–æŒ‰éˆ•çš„é‚è¼¯ç›´æ¥å¯«åœ¨é€™è£¡ï¼Œç¢ºä¿é»æ“Šé¡Œç›®å¾ŒæŒ‰éˆ• 100% å¯ä»¥æ“ä½œã€‚
            currentActiveBoxes.forEach(box => {
                box.classList.add('reading');
                box.classList.remove('paused');
            });
            updateButtonsState(true, false);

            playNextChunk();
        }

        function playNextChunk() {
            if (isReadingStopped) return;

            while (currentChunkIndex < chunkQueue.length && chunkQueue[currentChunkIndex].text.trim() === '') {
                let chunk = chunkQueue[currentChunkIndex];
                updateProgressBar(chunk.startIdx + chunk.length);
                currentChunkIndex++;
            }

            if (currentChunkIndex >= chunkQueue.length) {
                updateProgressBar(Number.MAX_SAFE_INTEGER); 
                setTimeout(() => {
                    if (!isReadingStopped) {
                        clearHighlights();
                        currentActiveBoxes = [];
                        updateButtonsState(false, false);
                        isReadingStopped = true;
                    }
                }, 500);
                return;
            }

            let chunk = chunkQueue[currentChunkIndex];
            
            let isOptionBullet = /[â‘ -â‘³]/.test(chunk.text);
            let isSquare = /[â–¡ï‚£â˜]/.test(chunk.text); 

            if ((isOptionBullet || isSquare) && chunk._hasPreDelayed !== true && !isResumingFromPause) {
                isWaitingInGap = true;
                chunk._hasPreDelayed = true; 
                let delayMs = 500; 
                
                // ç¢ºä¿åœ¨åœé “ 0.5 ç§’çš„ç·©è¡æœŸé–“ï¼Œæš«åœèˆ‡åœæ­¢æŒ‰éˆ•ä¾ç„¶ä¿æŒå¯é»æ“Šç‹€æ…‹
                currentActiveBoxes.forEach(box => {
                    box.classList.add('reading');
                    box.classList.remove('paused');
                });
                updateButtonsState(true, false);

                pauseTimeout = setTimeout(() => {
                    if (isReadingStopped || isReadingProcessPaused) return; 
                    isWaitingInGap = false;
                    playNextChunk(); 
                }, delayMs);
                return;
            }

            isWaitingInGap = false;

            if (!isResumingFromPause) {
                let speakText = chunk.text
                    .replace(/[ï¼-ï¼™]/g, m => String.fromCharCode(m.charCodeAt(0) - 0xFEE0)) 
                    .replace(/(^|\D)0+(\d+)/g, '$1$2'); // ã€ç‰©ç†æ‹”é™¤æ‰€æœ‰æ•¸å­—é–‹é ­çš„ 0ã€‘

                // æ•¸å­—è½‰ç´”ä¸­æ–‡å‡½æ•¸ï¼Œé˜²ç¦¦èªéŸ³å¼•æ“è‡ªä½œä¸»å¼µåŠ ã€Œé›¶ã€
                const numToZh = (nStr) => {
                    const n = parseInt(nStr, 10);
                    const arr = ['', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
                    if (n > 0 && n < 10) return arr[n];
                    if (n === 10) return 'å';
                    if (n > 10 && n < 20) return 'å' + arr[n - 10];
                    if (n >= 20 && n % 10 === 0) return arr[Math.floor(n / 10)] + 'å';
                    if (n > 20 && n < 100) return arr[Math.floor(n / 10)] + 'å' + arr[n % 10];
                    return nStr; 
                };

                // ã€å»æ¸…å–®åŒ–ï¼Œå¾¹åº•æ¶ˆæ»…é›¶éŸ³ã€‘ï¼š
                // æ“´å……å°ã€Œ1ã€ã€ã€ã€Œ1ï¼ã€çš„æ”¯æ´ï¼Œè½‰æˆã€Œä¸€ï¼Œã€ï¼Œé€—è™Ÿèƒ½ç¢ºä¿æ–·å¥ä¸”ä¿è­‰åªå”¸ã€Œä¸€ã€
                speakText = speakText
                    .replace(/(?:[\(ï¼ˆ])(\d{1,2})(?:[\)ï¼‰])/g, (m, d) => numToZh(d) + 'ï¼Œ') // (1) -> ä¸€ï¼Œ
                    // è‹¥å°æ•¸é»/é “è™Ÿå¾Œé¢ä¸æ˜¯æ•¸å­—ï¼Œä»£è¡¨æ˜¯é¡Œè™Ÿï¼Œå°‡å…¶è½‰ç‚ºã€Œä¸€ï¼Œã€
                    .replace(/(\d{1,2})(?:\.|ï¼|ã€)(?=[^\d]|$)/g, (m, d) => numToZh(d) + 'ï¼Œ') 
                    .replace(/(^|[^\d])(\d{1,2})(?=[^\d]|$)/g, (m, p1, d) => p1 + numToZh(d)) // è™•ç†å‰©ä¸‹çš„ç¨ç«‹æ•¸å­—
                    .replace(/æ‰“[vVï½–ï¼¶Ë‡]/g, 'æ‰“å‹¾')
                    .replace(/Ë‡/g, 'æ‰“å‹¾');

                let isAtLineStart = /(^|\n)\s*$/.test(currentOriginalText.substring(0, chunk.startIdx));
                if (isAtLineStart) {
                    speakText = speakText.replace(/[â–¡ï‚£â˜]/g, ''); 
                } else {
                    speakText = speakText.replace(/[â–¡ï‚£â˜]/g, 'æ–¹æ¡†'); 
                }

                speakText = speakText
                    .replace(/å£(?=ä¸­æ‰“)/g, 'æ–¹æ¡†')
                    // ã€å…¨è‡ªå‹•åœ“åœˆæ•¸å­—ç¿»è­¯æ©Ÿã€‘ï¼šè½‰æˆã€Œä¸€ï¼Œã€ï¼Œå¾¹åº•é˜»çµ•ã€Œé›¶ä¸€ã€
                    .replace(/[â‘ -â‘³]/g, match => { 
                        const num = match.charCodeAt(0) - 9311;
                        return numToZh(num.toString()) + 'ï¼Œ';
                    })
                    .replace(/ã„…/g, 'æ³¢ã€')
                    .replace(/ã„†/g, 'å¡ã€')
                    .replace(/ã„‡/g, 'æ‘¸ã€')
                    .replace(/ã„ˆ/g, 'ä½›ã€')
                    .replace(/ã„‰/g, 'å¾—ã€')
                    .replace(/ã„Š/g, 'ç‰¹ã€')
                    // ã€çµ‚æ¥µä¿éšªã€‘ï¼šä»»ä½•æ®˜ç•™çš„ã€Œé›¶ä¸€ã€~ã€Œé›¶ä¹ã€å¼·åˆ¶æ‹”é™¤ã€Œé›¶ã€
                    .replace(/é›¶([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹])/g, '$1');

                currentSpeakText = speakText;
                pausedCharIndex = 0;
            }

            let textToSpeak = currentSpeakText.substring(pausedCharIndex);
            baseCharIndex = pausedCharIndex; 

            currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
            currentUtterance.lang = 'zh-TW';
            currentUtterance.rate = parseFloat(speedInput.value);

            currentUtterance.onstart = () => {
                if (isReadingStopped || isReadingProcessPaused) return; 
                isWaitingInGap = false;
                // (æŒ‰éˆ•è§£é–é‚è¼¯å·²ç§»è‡³ä¸Šæ–¹ï¼Œç¢ºä¿ä¸å—ç€è¦½å™¨ onstart æ¼ç™¼çš„å½±éŸ¿)
            };

            currentUtterance.onboundary = (event) => {
                if (isReadingStopped || isReadingProcessPaused) return; 
                pausedCharIndex = baseCharIndex + event.charIndex; 
                let progressRatio = currentSpeakText.length > 0 ? (pausedCharIndex / currentSpeakText.length) : 0;
                let currentGlobalIdx = chunk.startIdx + Math.floor(chunk.length * progressRatio);
                updateProgressBar(currentGlobalIdx);
            };

            currentUtterance.onend = () => {
                if (isReadingStopped || isReadingProcessPaused) return; 

                updateProgressBar(chunk.startIdx + chunk.length); 
                currentChunkIndex++;
                isResumingFromPause = false;
                pausedCharIndex = 0;
                
                if (chunk.isNumber) {
                    isWaitingInGap = true;
                    pauseTimeout = setTimeout(() => {
                        if (isReadingStopped || isReadingProcessPaused) return; 
                        playNextChunk(); 
                    }, 500);
                } else {
                    playNextChunk(); 
                }
            };

            currentUtterance.onerror = (e) => {
                if (isReadingStopped || isReadingProcessPaused) return; 
                
                if (e.error !== 'canceled') {
                    currentChunkIndex++;
                    isResumingFromPause = false;
                    pausedCharIndex = 0;
                    playNextChunk();
                }
            };

            if (!isReadingProcessPaused) {
                synth.speak(currentUtterance);
            }
        }

        function updateProgressBar(currentGlobalIdx) {
            if (chunkQueue.length === 0) return;
            let lastChunk = chunkQueue[chunkQueue.length - 1];
            let totalLength = lastChunk.startIdx + lastChunk.length;
            let percentage = totalLength === 0 ? 100 : (currentGlobalIdx / totalLength) * 100;
            if (percentage > 100) percentage = 100;
            currentActiveBoxes.forEach(box => {
                let pb = box.querySelector('.progress-bar');
                if (pb) pb.style.width = percentage + '%';
            });
        }

        function pauseReading() {
            if (currentActiveBoxes.length > 0 && !isReadingProcessPaused && !isReadingStopped) {
                isReadingProcessPaused = true;
                if (!isWaitingInGap) {
                    synth.cancel(); 
                } else {
                    clearTimeout(pauseTimeout); 
                }
                currentActiveBoxes.forEach(box => {
                    box.classList.remove('reading');
                    box.classList.add('paused');
                });
                updateButtonsState(true, true);
            }
        }

        function resumeReading() {
            if (isReadingProcessPaused) {
                isReadingProcessPaused = false;
                
                synth.resume(); 
                
                if (isWaitingInGap) {
                    isWaitingInGap = false;
                    playNextChunk(); 
                } else {
                    isResumingFromPause = true;
                    playNextChunk(); 
                }

                currentActiveBoxes.forEach(box => {
                    box.classList.remove('paused');
                    box.classList.add('reading');
                });
                updateButtonsState(true, false);
            }
        }

        function stopReading() {
            isReadingStopped = true;
            isReadingProcessPaused = false;
            clearTimeout(pauseTimeout);
            synth.cancel();
            clearHighlights();
            currentActiveBoxes = [];
            updateButtonsState(false, false);
            isResumingFromPause = false;
            pausedCharIndex = 0;
        }

        function resetSystem() {
            stopReading(); 
            
            document.getElementById('pdf-viewer').innerHTML = '';
            document.getElementById('pdf-viewer').style.opacity = '0';
            
            document.getElementById('status-text').innerText = "è«‹é¸æ“‡è¼‰å…¥æ–¹å¼ï¼šæœ¬æ©Ÿä¸Šå‚³ æˆ– GitHub é¡Œåº«ä¸‹è¼‰ã€‚";
            document.getElementById('status-text').style.color = "#7f8c8d";
            
            document.getElementById('pdf-upload').value = '';
            
            document.getElementById('btn-fetch-list').style.display = 'inline-block';
            document.getElementById('btn-fetch-list').innerText = 'ğŸ” ç€è¦½ç·šä¸Šé¡Œåº«åˆ—è¡¨';
            document.getElementById('btn-fetch-list').disabled = false;
            document.getElementById('github-select').style.display = 'none';
            document.getElementById('btn-load-selected').style.display = 'none';
            
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('upload-screen').style.display = 'flex';
        }

        window.onbeforeunload = () => synth.cancel();
    </script>
</body>
</html>