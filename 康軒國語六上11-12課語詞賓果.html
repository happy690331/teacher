<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>康軒國語六上11-12課語詞解釋賓果遊戲</title>
    <!-- 載入 Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 載入 Icon for the Heart symbol -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* 自定義 Tailwind 設定 */
        :root {
            --bingo-grid-size: min(90vw, 500px);
            --ribbon-offset: 25px; /* 彩帶與賓果卡之間的間距 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            position: relative; /* 讓彩帶可以相對於 body 定位 */
        }
        /* Bingo Card Custom Styling */
        .bingo-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            width: var(--bingo-grid-size);
            height: var(--bingo-grid-size);
            max-width: 500px;
            max-height: 500px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            border-radius: 1rem;
            overflow: hidden;
            background-color: #fff;
        }
        .bingo-cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #ddd;
            cursor: pointer;
            text-align: center;
            transition: transform 0.3s ease-in-out, background-color 0.3s;
            padding: 5px;
            font-weight: bold;
            overflow: hidden;
            flex-shrink: 0; 
        }
        .cell-content {
            padding: 5px;
            word-break: break-all;
            max-height: 100%;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .word {
            font-size: clamp(1rem, 4vw, 1.8rem); /* 語詞字體較大 */
            color: #1e40af; /* 藍色 */
        }
        .definition {
            font-size: clamp(0.7rem, 2.5vw, 1rem); /* 解釋字體較小 */
            color: #4b5563; /* 灰色 */
        }
        .center-cell {
            background-color: #fef3c7; /* 中心格特別色 */
            color: #d97706; /* 橘色 */
            /* 調整字體大小，使其更小，更容易在單行顯示 */
            font-size: clamp(1rem, 3vw, 1.5rem); 
        }
        .marked {
            background-color: #fee2e2; /* 標記後的背景 */
        }
        .heart {
            color: #ef4444; /* 愛心紅色 */
            font-size: clamp(2rem, 8vw, 3rem);
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        .bingo-line {
            position: absolute;
            background-color: rgba(239, 68, 68, 0.7); /* 紅色連線 */
            z-index: 10;
            pointer-events: none;
            border-radius: 9999px;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .row-line { height: 8px; width: 100%; }
        .col-line { width: 8px; height: 100%; }
        .diag-down-line { height: 8px; width: 141.42%; transform: rotate(45deg); }
        .diag-up-line { height: 8px; width: 141.42%; transform: rotate(-45deg); }

        /* 彩帶效果 CSS */
        .ribbon-effect {
            position: absolute;
            width: 20px; 
            height: var(--bingo-grid-size); 
            z-index: 9;
            pointer-events: none;
            background-color: transparent;
            border-radius: 0.5rem;
            opacity: 0;
            transition: opacity 0.1s ease-out;
        }
        .ribbon-flash {
            background: linear-gradient(to bottom, #fee2e2, #f87171, #fee2e2);
            opacity: 1;
            animation: ribbonFlash 0.5s linear infinite;
        }
        @keyframes ribbonFlash {
            0%, 100% { box-shadow: 0 0 10px #f87171; opacity: 1; }
            50% { box-shadow: 0 0 20px #ef4444; opacity: 0.8; }
        }

        /* 主持人畫面 */
        .overlay-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 50;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-card {
            background-color: #fff;
            padding: 30px;
            border-radius: 1.5rem;
            max-width: 90%;
            min-height: 50vh;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- 恭喜音效的 Audio 元素：設定 preload="auto" 以利音效快速播放 -->
    <audio id="winSound" src="http://googleusercontent.com/file_content/1" preload="auto"></audio>

    <h1 class="text-3xl sm:text-4xl font-extrabold text-blue-700 mb-6 text-center w-full max-w-lg">
        康軒國語六上11-12課語詞解釋賓果遊戲
    </h1>

    <!-- 賓果連線計數顯示區 -->
    <div id="scoreDisplay" class="mb-4 p-3 text-2xl font-extrabold text-red-600 bg-white rounded-xl shadow-lg transition duration-300 transform scale-100">
        目前連成 0 條線
    </div>

    <!-- 賓果遊戲卡區 -->
    <div id="bingoGridContainer" class="relative">
        <div id="bingoGrid" class="bingo-grid">
            <!-- 賓果格子將由 JavaScript 渲染 -->
        </div>
        
        <!-- 彩帶效果元素 (定位於賓果卡兩側) -->
        <div id="leftRibbon" class="ribbon-effect" style="left: calc(0% - var(--ribbon-offset)); top: 0;"></div>
        <div id="rightRibbon" class="ribbon-effect" style="right: calc(0% - var(--ribbon-offset)); top: 0;"></div>
    </div>

    <!-- 控制按鈕區 -->
    <div class="mt-8 flex flex-wrap justify-center gap-4 w-full max-w-md">
        <button id="btnRandomize" class="px-6 py-3 bg-blue-500 hover:bg-blue-700 text-white font-bold rounded-lg shadow-md transition duration-150">
            重新配置
        </button>
        <button id="btnStartGame" class="px-6 py-3 bg-green-500 hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-150">
            固定配置
        </button>
        <button id="btnHost" class="px-6 py-3 bg-purple-500 hover:bg-purple-700 text-white font-bold rounded-lg shadow-md transition duration-150">
            主持人
        </button>
    </div>

    <!-- 已選語詞顯示區 -->
    <div id="selectedWordsDisplay" class="mt-6 p-4 text-lg font-semibold text-gray-800 bg-white rounded-xl shadow-lg w-full max-w-lg text-center break-words">
        已選語詞: (無)
    </div>

    <!-- 主持人畫面 (Overlay) -->
    <div id="hostScreen" class="overlay-modal">
        <div class="modal-card">
            <h2 class="text-3xl font-bold mb-6 text-gray-800">主持人語詞抽籤機</h2>
            
            <div id="hostStatus" class="mb-6 p-3 text-xl font-semibold text-gray-600 bg-gray-100 rounded-lg w-full max-w-sm">
                點擊「抽取語詞解釋」開始
            </div>

            <!-- 抽取的內容顯示區 -->
            <div id="drawnContent" class="min-h-24 mb-8 flex flex-col justify-center items-center">
                <p id="currentDef" class="definition text-2xl font-medium text-purple-700 px-4 transition duration-300 transform scale-100"></p>
                <p id="currentWord" class="word text-4xl font-extrabold text-blue-600 mt-4 hidden transition duration-300 transform scale-110">?</p>
            </div>
            
            <!-- 主持人操作按鈕 -->
            <div class="flex flex-col gap-4 w-full max-w-xs">
                <button id="btnDrawWord" class="px-6 py-3 bg-red-500 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    抽取語詞解釋
                </button>
                <button id="btnRevealWord" class="px-6 py-3 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded-xl shadow-lg transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                    顯示語詞
                </button>
                
                <!-- 已出現過的語詞顯示區 (新增) -->
                <div id="hostRevealedWords" class="mt-4 p-3 text-base font-medium text-gray-700 bg-gray-50 rounded-lg w-full text-left break-words">
                    已出現過的語詞: (無)
                </div>
                
                <button id="btnCloseHost" class="mt-4 px-6 py-3 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold rounded-xl shadow-md transition duration-200">
                    關閉主持人畫面
                </button>
            </div>

            <p id="hostRemainingCount" class="mt-6 text-sm text-gray-500">
                剩餘詞彙數量：24
            </p>
        </div>
    </div>

    <script>
        // -----------------------------------------------------
        // 1. 遊戲資料 (已更新為 11-12 課，並移除人名、地名)
        // -----------------------------------------------------

        // 總計 22 個詞彙，為了湊滿 24 個格子，重複了 "恢復" 和 "活潑"。
        const ALL_WORDS = [
            { word: '恢復', def: '⑴回復到原來的樣子。⑵收復，將失去的收回來。' },
            { word: '活潑', def: '生動而不呆板。' },
            { word: '恢復', def: '⑴回復到原來的樣子。⑵收復，將失去的收回來。' }, // 重複 1
            { word: '活潑', def: '生動而不呆板。' }, // 重複 2
            { word: '草莓', def: '植物名。果實肉質多汁，味道酸甜，可生食或製果醬。' },
            { word: '客廳', def: '用來接待賓客的場所。' },
            { word: '前額', def: '額頭。' },
            { word: '灌醉', def: '勉強別人喝酒以致於酒醉。' },
            { word: '原諒', def: '寬恕諒解。' },
            { word: '雙脣', def: '上、下嘴脣。' },
            { word: '乞求', def: '懇求、請求。' },
            { word: '神采煥發', def: '精神充足，光采照人。' },
            { word: '雪橇', def: '利用長條形平滑板塊在雪地上滑行的無輪交通工具。' },
            { word: '迴盪', def: '迴旋飄浮。' },
            { word: '訝異', def: '覺得意外，難以相信。' },
            { word: '臉頰', def: '臉的兩邊。' },
            { word: '蓬勃', def: '茂盛繁榮的樣子。' },
            { word: '家庭醫師', def: '照顧家庭各成員健康的第一線醫師。' },
            { word: '嚴肅', def: '⑴態度嚴正莊重。⑵嚴格、認真。' },
            { word: '薔薇', def: '植物名。枝幹多刺，花朵有紅、白、黃等色，富有香氣。' },
            { word: '瀰漫', def: '遍布、滿布。' },
            { word: '包括', def: '包含、涵蓋。' },
            { word: '螞蟻', def: '蟻科昆蟲的總稱。喜於地下築巢群居，職分女王蟻、雄蟻、工蟻三種。' },
            { word: '儘管', def: '⑴即使、雖然。⑵不用考慮其他因素或加以節制，隨意去做。' }
        ];

        // -----------------------------------------------------
        // 2. 遊戲狀態
        // -----------------------------------------------------

        let gameState = 'randomizing'; // 'randomizing' (重新配置), 'playing' (固定配置), 'host' (主持人模式)
        let grid = []; // 5x5 的賓果卡資料
        let lineCount = 0; // 連線數
        let availableWords = [...ALL_WORDS]; // 剩餘可抽取的語詞
        let drawnWords = []; // 已抽取的語詞 (在 Host 模式下，用於記錄已揭示的語詞)
        let currentDrawnWord = null; // 主持人畫面當前抽到的語詞

        // DOM 元素引用
        const $gridContainer = document.getElementById('bingoGridContainer');
        const $bingoGrid = document.getElementById('bingoGrid');
        const $scoreDisplay = document.getElementById('scoreDisplay');
        const $btnRandomize = document.getElementById('btnRandomize');
        const $btnStartGame = document.getElementById('btnStartGame');
        const $btnHost = document.getElementById('btnHost');
        const $hostScreen = document.getElementById('hostScreen');
        const $btnDrawWord = document.getElementById('btnDrawWord');
        const $btnRevealWord = document.getElementById('btnRevealWord');
        const $btnCloseHost = document.getElementById('btnCloseHost');
        const $hostStatus = document.getElementById('hostStatus');
        const $currentDef = document.getElementById('currentDef');
        const $currentWord = document.getElementById('currentWord');
        const $hostRemainingCount = document.getElementById('hostRemainingCount');
        const $winSound = document.getElementById('winSound'); // Audio 元素
        // 新增/修改的 DOM 引用
        const $leftRibbon = document.getElementById('leftRibbon');
        const $rightRibbon = document.getElementById('rightRibbon');
        const $selectedWordsDisplay = document.getElementById('selectedWordsDisplay');
        const $hostRevealedWords = document.getElementById('hostRevealedWords'); // 新增的主持人已出現語詞顯示區


        // -----------------------------------------------------
        // 3. 核心邏輯函數
        // -----------------------------------------------------

        /**
         * 洗牌函數 (Fisher-Yates)
         * @param {Array} array 要洗牌的陣列
         * @returns {Array} 洗牌後的陣列
         */
        function shuffle(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        /**
         * 隨機選擇 24 個語詞並建立 5x5 賓果卡
         */
        function initializeGrid() {
            // 隨機選出 24 個語詞
            const shuffledWords = shuffle([...ALL_WORDS]).slice(0, 24);
            const gridItems = shuffledWords.map(item => ({
                ...item,
                state: 0, // 0: Word, 1: Heart, 2: Definition
                isCenter: false,
                isMarked: false,
            }));

            // 插入萬用格 (PASS)
            gridItems.splice(12, 0, { // 25格，中間是第12個索引 (0-24)
                word: 'PASS',
                def: '萬用格',
                state: 1, // 萬用格預設為標記狀態
                isCenter: true,
                isMarked: true,
            });

            // 將一維陣列轉換為 5x5 二維陣列
            grid = [];
            for (let i = 0; i < 5; i++) {
                grid.push(gridItems.slice(i * 5, (i + 1) * 5));
            }
            lineCount = 0;
            updateScoreDisplay();
        }

        /**
         * 渲染賓果卡到 DOM 上
         */
        function renderGrid() {
            $bingoGrid.innerHTML = '';
            // 清除舊的連線
            $gridContainer.querySelectorAll('.bingo-line').forEach(line => line.remove());

            grid.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'bingo-cell relative';
                    cellDiv.dataset.row = rowIndex;
                    cellDiv.dataset.col = colIndex;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'cell-content';

                    if (cell.isCenter) {
                        cellDiv.classList.add('center-cell', 'marked');
                        contentDiv.innerHTML = cell.word; // 顯示 PASS
                    } else {
                        // 處理一般格子的顯示狀態
                        let innerHTML = '';
                        let contentClass = '';

                        if (cell.state === 0) { // 語詞
                            innerHTML = `<span class="word">${cell.word}</span>`;
                            contentClass = 'word';
                        } else if (cell.state === 1) { // 愛心
                            innerHTML = `<i class="fas fa-heart heart"></i>`;
                            contentClass = 'heart';
                            cellDiv.classList.add('marked');
                        } else if (cell.state === 2) { // 解釋
                            innerHTML = `<span class="definition">${cell.def}</span>`;
                            contentClass = 'definition';
                            cellDiv.classList.add('marked');
                        }

                        contentDiv.innerHTML = innerHTML;
                        contentDiv.classList.add(contentClass);

                        if (cell.isMarked && cell.state !== 1 && cell.state !== 2) {
                             cellDiv.classList.remove('marked'); // 避免未標記狀態仍有 marked 樣式
                        }
                    }

                    cellDiv.appendChild(contentDiv);
                    $bingoGrid.appendChild(cellDiv);

                    // 僅在 'playing' 狀態下添加點擊事件
                    if (gameState === 'playing' && !cell.isCenter) {
                        cellDiv.onclick = handleCellClick;
                    }
                });
            });

            // 重新檢查並繪製連線
            if (gameState === 'playing') {
                checkBingo(true); // true 代表是渲染時的檢查
                updateSelectedWordsDisplay();
            }
        }

        /**
         * 處理遊戲卡單元格點擊 (Word -> Heart -> Definition -> Word)
         * @param {Event} event 點擊事件
         */
        function handleCellClick(event) {
            if (gameState !== 'playing') return;

            const cellDiv = event.currentTarget;
            const row = parseInt(cellDiv.dataset.row);
            const col = parseInt(cellDiv.dataset.col);
            const cell = grid[row][col];

            if (cell.isCenter) return; // 萬用格不能點擊改變狀態
            
            cell.state = (cell.state + 1) % 3;

            // 更新 isMarked 狀態
            cell.isMarked = (cell.state !== 0);

            // 重新渲染該單元格，並檢查賓果
            renderGrid();
        }

        /**
         * 檢查賓果連線並更新樣式
         * @param {boolean} redraw 是否為重新渲染時調用 (用於繪製連線，不重複計算 lineCount)
         */
        function checkBingo(redraw = false) {
            const lines = []; // 儲存所有連線的資訊
            const BINGO_SIZE = 5;
            const oldLines = lineCount; // 捕捉當前連線數

            // 檢查所有行 (Rows)
            for (let i = 0; i < BINGO_SIZE; i++) {
                if (grid[i].every(cell => cell.isMarked)) {
                    lines.push({ type: 'row', index: i });
                }
            }

            // 檢查所有列 (Columns)
            for (let j = 0; j < BINGO_SIZE; j++) {
                let isBingo = true;
                for (let i = 0; i < BINGO_SIZE; i++) {
                    if (!grid[i][j].isMarked) {
                        isBingo = false;
                        break;
                    }
                }
                if (isBingo) {
                    lines.push({ type: 'col', index: j });
                }
            }

            // 檢查主對角線 (Top-Left to Bottom-Right)
            let diag1Bingo = true;
            for (let i = 0; i < BINGO_SIZE; i++) {
                if (!grid[i][i].isMarked) {
                    diag1Bingo = false;
                    break;
                }
            }
            if (diag1Bingo) {
                lines.push({ type: 'diag', index: 1 });
            }

            // 檢查副對角線 (Top-Right to Bottom-Left)
            let diag2Bingo = true;
            for (let i = 0; i < BINGO_SIZE; i++) {
                if (!grid[i][BINGO_SIZE - 1 - i].isMarked) {
                    diag2Bingo = false;
                    break;
                }
            }
            if (diag2Bingo) {
                lines.push({ type: 'diag', index: 2 });
            }
            
            const newLines = lines.length;

            // 繪製連線樣式
            if (redraw) {
                drawBingoLines(lines);
                lineCount = newLines;
            } else {
                lineCount = newLines;
            }

            updateScoreDisplay();

            // 檢查是否連成新的線
            if (lineCount > oldLines) {
                showCongrats(); // 播放彩帶效果
                playWinSound(); // 播放音效
            }
        }

        /**
         * 在賓果格上繪製紅色的連線樣式
         * @param {Array} lines - 包含連線類型和索引的陣列
         */
        function drawBingoLines(lines) {
            lines.forEach(line => {
                const lineDiv = document.createElement('div');
                lineDiv.classList.add('bingo-line');
                
                const gridWidth = $bingoGrid.offsetWidth;
                const cellSize = gridWidth / 5;
                const offset = cellSize / 2;

                if (line.type === 'row') {
                    lineDiv.classList.add('row-line');
                    // 行連線: 位於該行中心
                    lineDiv.style.top = `${line.index * cellSize + offset - 4}px`;
                    lineDiv.style.left = '0';
                } else if (line.type === 'col') {
                    lineDiv.classList.add('col-line');
                    // 列連線: 位於該列中心
                    lineDiv.style.left = `${line.index * cellSize + offset - 4}px`;
                    lineDiv.style.top = '0';
                } else if (line.type === 'diag') {
                    // 對角線連線: 需要旋轉
                    // 對角線的寬度是 (5 * cellSize) * sqrt(2) ≈ 1.4142 * gridWidth
                    lineDiv.style.left = `${offset - 4}px`;
                    lineDiv.style.top = `${offset - 4}px`;

                    if (line.index === 1) { // 主對角線 ( \ )
                        lineDiv.classList.add('diag-down-line');
                        lineDiv.style.transformOrigin = 'top left';
                    } else if (line.index === 2) { // 副對角線 ( / )
                        lineDiv.classList.add('diag-up-line');
                        // 調整副對角線的位置，使其通過中心
                        lineDiv.style.transformOrigin = 'top right';
                        lineDiv.style.left = `${gridWidth - offset + 4}px`;
                    }
                }
                $gridContainer.appendChild(lineDiv);
            });
        }

        /**
         * 更新上方的連線計數顯示
         */
        function updateScoreDisplay() {
            $scoreDisplay.textContent = `目前連成 ${lineCount} 條線`;
        }

        /**
         * 更新底部已選語詞列表 (玩家介面)
         */
        function updateSelectedWordsDisplay() {
            const selectedWords = [];

            grid.forEach(row => {
                row.forEach(cell => {
                    // 檢查是否被標記 (state 1: Heart, state 2: Definition) 且不是萬用格
                    if (cell.isMarked && !cell.isCenter) {
                        selectedWords.push(cell.word);
                    }
                });
            });

            const wordsText = selectedWords.length > 0
                ? selectedWords.join('、')
                : '(無)';

            $selectedWordsDisplay.textContent = `已選語詞: ${wordsText}`;
        }

        // -----------------------------------------------------
        // 4. 恭喜畫面與音效
        // -----------------------------------------------------

        /**
         * 播放恭喜音效 (使用提供的 clapping.mp3)
         */
        function playWinSound() {
            if ($winSound) {
                // 重設播放時間到開頭
                $winSound.currentTime = 0; 
                // 嘗試播放，捕捉潛在的 Promise 錯誤 (例如瀏覽器自動播放限制)
                $winSound.play().catch(e => {
                    console.warn("無法播放音效：可能受到瀏覽器自動播放限制。", e);
                });
            } else {
                console.error("找不到 #winSound 元素。");
            }
        }

        /**
         * 顯示恭喜連線畫面 (使用彩帶效果替換 Modal)
         */
        function showCongrats() {
            // 移除 Modal 邏輯，改為閃爍彩帶效果
            // 讓彩帶閃爍 0.5s，與 CSS 動畫配合
            $leftRibbon.classList.add('ribbon-flash');
            $rightRibbon.classList.add('ribbon-flash');

            // 移除動畫 class
            setTimeout(() => {
                $leftRibbon.classList.remove('ribbon-flash');
                $rightRibbon.classList.remove('ribbon-flash');
            }, 500); 
        }

        // -----------------------------------------------------
        // 5. 主控按鈕事件處理 (新增鎖定邏輯)
        // -----------------------------------------------------

        /**
         * 處理「重新配置」按鈕點擊 - ONLY WORKS BEFORE GAME STARTS
         */
        $btnRandomize.onclick = () => {
            // 只有在遊戲尚未固定配置時才允許重新配置
            if ($btnStartGame.disabled || gameState === 'host') return; 

            gameState = 'randomizing';
            initializeGrid();
            renderGrid();
            $scoreDisplay.textContent = '請點擊「固定配置」開始遊戲';
            $btnStartGame.classList.remove('bg-gray-500');
            $btnStartGame.classList.add('bg-green-500', 'hover:bg-green-700');
            console.log("遊戲進入「重新配置」狀態。語詞已打亂，點擊無效。");
        };

        /**
         * 處理「固定配置」按鈕點擊 (新增按鈕鎖定)
         */
        $btnStartGame.onclick = () => {
            if (gameState === 'host') return;
            if (gameState === 'randomizing' || grid.length === 0) {
                // 如果是從隨機配置切換，則固定配置，並鎖定控制按鈕
                gameState = 'playing';
                renderGrid(); // 重新渲染以添加點擊事件
                $scoreDisplay.textContent = `目前連成 ${lineCount} 條線`;

                // --- 鎖定控制按鈕 ---
                $btnStartGame.disabled = true;
                $btnRandomize.disabled = true;
                $btnHost.disabled = true;
                
                // Style updates for disabled state (使用 bg-gray-500 來表示鎖定)
                $btnStartGame.classList.add('opacity-50', 'cursor-not-allowed');
                $btnRandomize.classList.add('opacity-50', 'cursor-not-allowed');
                $btnHost.classList.add('opacity-50', 'cursor-not-allowed');
                
                // 移除 hover 效果並設置鎖定顏色
                $btnStartGame.classList.remove('hover:bg-green-700', 'bg-green-500');
                $btnStartGame.classList.add('bg-gray-500'); 
                $btnRandomize.classList.remove('hover:bg-blue-700', 'bg-blue-500');
                $btnRandomize.classList.add('bg-blue-300');
                $btnHost.classList.remove('hover:bg-purple-700', 'bg-purple-500');
                $btnHost.classList.add('bg-purple-300');
                
                console.log("遊戲進入「固定配置」狀態。點擊格子開始遊戲。控制按鈕已鎖定。");
            } else if (gameState === 'playing') {
                console.log("遊戲已在「固定配置」狀態，控制按鈕已鎖定。");
            }
        };

        /**
         * 處理「主持人」按鈕點擊
         */
        $btnHost.onclick = () => {
            if ($btnHost.disabled) return; // 鎖定狀態下無法進入

            gameState = 'host';
            $hostScreen.style.display = 'flex';
            initializeHostScreen();
            console.log("遊戲進入「主持人」模式。");
        };

        // -----------------------------------------------------
        // 6. 主持人畫面邏輯
        // -----------------------------------------------------

        /**
         * 更新主持人畫面已出現過的語詞列表
         */
        function updateHostRevealedWordsDisplay() {
            const wordsText = drawnWords.map(item => item.word).join('、');
            $hostRevealedWords.textContent = `已出現過的語詞: ${wordsText || '(無)'}`;
        }

        /**
         * 初始化主持人畫面狀態
         */
        function initializeHostScreen() {
            availableWords = [...ALL_WORDS];
            drawnWords = [];
            currentDrawnWord = null;
            $currentDef.textContent = '';
            $currentWord.textContent = '?';
            $currentWord.classList.add('hidden');
            $btnRevealWord.disabled = true;
            $btnDrawWord.disabled = false;
            $hostStatus.textContent = '點擊「抽取語詞解釋」開始';
            updateHostRemainingCount();
            updateHostRevealedWordsDisplay(); // 初始化已出現語詞顯示
        }

        /**
         * 抽取詞彙
         */
        $btnDrawWord.onclick = () => {
            if (availableWords.length === 0) {
                $hostStatus.textContent = '所有詞彙已抽取完畢！';
                $btnDrawWord.disabled = true;
                $btnRevealWord.disabled = true;
                return;
            }

            // 隨機選一個詞
            const randomIndex = Math.floor(Math.random() * availableWords.length);
            currentDrawnWord = availableWords.splice(randomIndex, 1)[0];
            // 注意：這裡只從 availableWords 移除，不推入 drawnWords，直到揭示答案

            // 顯示解釋，隱藏語詞
            $currentDef.textContent = currentDrawnWord.def;
            $currentWord.textContent = '?';
            $currentWord.classList.add('hidden');
            $btnRevealWord.disabled = false;
            $hostStatus.textContent = '請根據解釋猜語詞...';
            $btnDrawWord.disabled = true; // 抽完後禁用，直到揭示完畢

            updateHostRemainingCount();
            console.log(`抽取詞彙: ${currentDrawnWord.def}`);
        };

        /**
         * 顯示語詞
         */
        $btnRevealWord.onclick = () => {
            if (!currentDrawnWord) return;

            $currentWord.textContent = currentDrawnWord.word;
            $currentWord.classList.remove('hidden');
            $hostStatus.textContent = `正確答案是：「${currentDrawnWord.word}」`;
            
            // 揭示答案後，將該詞加入已出現的列表
            // 檢查是否已存在，防止因為重複詞彙而多次記錄
            if (!drawnWords.some(item => item.word === currentDrawnWord.word && item.def === currentDrawnWord.def)) {
                drawnWords.push(currentDrawnWord);
            }
            updateHostRevealedWordsDisplay(); // 更新列表顯示

            // 揭示完畢後，禁用揭示按鈕，啟用抽取按鈕
            $btnRevealWord.disabled = true;
            $btnDrawWord.disabled = (availableWords.length === 0);
            
            // 清空當前詞彙，準備下一次抽取
            currentDrawnWord = null;
            console.log(`揭示語詞: ${$currentWord.textContent}`);
        };

        /**
         * 關閉主持人畫面
         */
        $btnCloseHost.onclick = () => {
            // 退出主持人模式後，由於「固定配置」已點擊，其他按鈕應保持禁用
            gameState = 'playing'; 
            $hostScreen.style.display = 'none';
            renderGrid(); // 確保遊戲卡狀態更新
            console.log("退出「主持人」模式，回到遊戲狀態。");
        };

        /**
         * 更新主持人畫面剩餘詞彙數量
         */
        function updateHostRemainingCount() {
            $hostRemainingCount.textContent = `剩餘詞彙數量：${availableWords.length}`;
        }

        // -----------------------------------------------------
        // 7. 初始啟動
        // -----------------------------------------------------

        // 頁面載入時，先執行一次重新配置
        initializeGrid();
        renderGrid();
        
        // 設置初始狀態提示
        $scoreDisplay.textContent = '請點擊「固定配置」開始遊戲';

        // 監聽窗口大小變化，確保連線能正確重繪
        window.addEventListener('resize', () => {
            if (gameState === 'playing') {
                checkBingo(true); // 重新檢查並繪製連線
            }
        });

    </script>
</body>
</html>