import React, { useState, useRef, useEffect } from 'react';
import { Download, Image as ImageIcon, BookOpen, Loader2, Sparkles, Pencil, Search, Type, Trash2 } from 'lucide-react';

const App = () => {
  const apiKey = ""; 
  
  const [inputText, setInputText] = useState('障');
  const [cards, setCards] = useState([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const [loadingStep, setLoadingStep] = useState('');
  const [html2canvasLoaded, setHtml2canvasLoaded] = useState(false);

  useEffect(() => {
    const script = document.createElement('script');
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js";
    script.async = true;
    script.onload = () => setHtml2canvasLoaded(true);
    document.body.appendChild(script);

    return () => {
      if (document.body.contains(script)) {
        document.body.removeChild(script);
      }
    };
  }, []);

  const fetchDictionaryData = async (char) => {
    const prompt = `
      你是一個專業的繁體中文小學國語字典。
      請針對生字：「${char}」提供以下資訊，用於製作教學學習單。
      
      請嚴格按照以下 JSON 格式回傳，不要有其他 markdown 標記：
      {
        "character": "${char}",
        "zhuyin": "注音符號 (例如 ㄓㄤˋ)",
        "radical": "部首 (例如 阜)",
        "strokes": "總筆畫數 (數字，例如 14)",
        "definition": "簡單定義 (用於生成圖片參考)",
        "words": ["詞語1", "詞語2"], 
        "sentence": "一個適合小學生閱讀，且包含「${char}」這個字的完整造句 (長度適中，約15-20字)。"
      }
    `;

    try {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: { responseMimeType: "application/json" }
          }),
        }
      );

      const data = await response.json();
      const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
      return JSON.parse(text);
    } catch (error) {
      console.error("Dictionary API Error:", error);
      throw new Error(`無法取得「${char}」的文字資訊`);
    }
  };

  const generateImage = async (char, definition) => {
    const prompt = `
      Create a simple, clear, flat vector style educational illustration for a flashcard.
      Subject: The concept of the Chinese character "${char}" which means "${definition}".
      Style: High contrast, colorful but simple, suitable for children's textbook.
      Background: White.
      IMPORTANT: DO NOT INCLUDE ANY TEXT, CHINESE CHARACTERS, OR LETTERS IN THE IMAGE. VISUALS ONLY.
    `;

    try {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: { 
                responseModalities: ["IMAGE"] 
            }
          }),
        }
      );

      const data = await response.json();
      const base64Image = data.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

      if (base64Image) {
        return `data:image/png;base64,${base64Image}`;
      }
      throw new Error("No image generated");
    } catch (error) {
      console.error("Image API Error:", error);
      return null;
    }
  };

  const handleGenerate = async () => {
    const charList = inputText.split(/[\s\n]+/).filter(c => c.trim().length > 0);
    
    if (charList.length === 0) return;

    setIsGenerating(true);
    setCards([]); 

    const newCards = [];

    for (const char of charList) {
      const cleanChar = char[0];
      
      try {
        setLoadingStep(`正在分析生字：「${cleanChar}」...`);
        const dictData = await fetchDictionaryData(cleanChar);
        
        setLoadingStep(`正在繪製插圖：「${cleanChar}」...`);
        const imageUrl = await generateImage(cleanChar, dictData.definition);

        newCards.push({
          id: Date.now() + Math.random(),
          ...dictData,
          imageUrl: imageUrl
        });
        
        setCards([...newCards]);

      } catch (err) {
        console.error(err);
      }
    }

    setIsGenerating(false);
    setLoadingStep('');
  };

  const handleClear = () => {
    setInputText('');
    setCards([]);
  };

  const downloadAll = async () => {
    if (!window.html2canvas) {
      alert("下載元件尚未載入，請稍後再試。");
      return;
    }

    const cardElements = document.querySelectorAll('.flashcard-container');
    
    if (cardElements.length === 0) {
      alert("沒有可下載的卡片");
      return;
    }

    // Wait slightly for DOM to be stable
    await new Promise(resolve => setTimeout(resolve, 300));

    for (let i = 0; i < cardElements.length; i++) {
      const element = cardElements[i];
      const char = element.dataset.char || `card_${i}`;
      
      try {
        const canvas = await window.html2canvas(element, {
            scale: 2, // Higher resolution
            useCORS: true,
            backgroundColor: '#ffffff',
            // CRITICAL FIX: Adjust styles ONLY during the capture phase
            onclone: (clonedDoc) => {
               // 1. Fix "Falling" Characters in Grids - Increased lift to 35%
               const textElements = clonedDoc.querySelectorAll('.tian-zi-ge-text-span');
               textElements.forEach(el => {
                   // Force lift the text up significantly
                   el.style.transform = 'translateY(-35%)'; 
                   el.style.display = 'block';
               });

               // 2. Fix Sentence Cut-off
               // Target the paragraph text
               const sentenceParagraphs = clonedDoc.querySelectorAll('.sentence-container p');
               sentenceParagraphs.forEach(el => {
                   el.style.lineHeight = '1.3'; // Comfortable line height
                   el.style.paddingBottom = '0px';
                   el.style.marginBottom = '0px';
               });
            }
        });
        
        const link = document.createElement('a');
        link.download = `${char}_生字學習單.png`;
        link.href = canvas.toDataURL('image/png');
        document.body.appendChild(link); 
        link.click();
        document.body.removeChild(link);
      } catch (e) {
        console.error("Download failed", e);
        alert(`下載「${char}」時發生錯誤，請重試`);
      }
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 p-4 md:p-8 font-sans text-gray-800">
      
      {/* Header & Controls */}
      <div className="max-w-6xl mx-auto mb-8 space-y-6">
        <div className="bg-white p-6 rounded-2xl shadow-sm border border-gray-100">
          <h1 className="text-3xl font-bold text-gray-800 mb-2 flex items-center gap-2">
            <BookOpen className="text-blue-600" />
            AI 生字學習單產生器
          </h1>
          <p className="text-gray-500 mb-6">
            依照指定格式生成：包含筆畫練習、語詞填空與句子練習 (15:9 窄版格式)
          </p>

          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">輸入生字 (可多個，以換行或空格分隔)</label>
              <textarea
                value={inputText}
                onChange={(e) => setInputText(e.target.value)}
                placeholder="例如：障"
                className="w-full h-24 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition-all resize-none text-xl"
              />
            </div>

            <div className="flex gap-3">
              <button
                onClick={handleGenerate}
                disabled={isGenerating}
                className={`flex-1 flex items-center justify-center gap-2 px-6 py-3 rounded-xl text-white font-medium transition-all ${
                  isGenerating
                    ? 'bg-gray-300 cursor-not-allowed' 
                    : 'bg-blue-600 hover:bg-blue-700 shadow-lg hover:shadow-xl'
                }`}
              >
                {isGenerating ? (
                  <><Loader2 className="animate-spin" /> {loadingStep}</>
                ) : (
                  <><Sparkles size={20} /> 開始製作</>
                )}
              </button>

              <button 
                onClick={handleClear}
                className="flex items-center justify-center gap-2 px-6 py-3 rounded-xl bg-gray-500 text-white font-medium hover:bg-gray-600 shadow-lg hover:shadow-xl transition-all"
              >
                <Trash2 size={20} /> 清除內容
              </button>

              {cards.length > 0 && (
                <button
                  onClick={downloadAll}
                  disabled={!html2canvasLoaded}
                  className={`flex items-center justify-center gap-2 px-6 py-3 rounded-xl text-white font-medium shadow-lg hover:shadow-xl transition-all ${
                    html2canvasLoaded 
                      ? 'bg-green-600 hover:bg-green-700' 
                      : 'bg-gray-400 cursor-not-allowed'
                  }`}
                >
                  <Download size={20} /> {html2canvasLoaded ? '全部下載' : '載入中...'}
                </button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Cards Output Grid */}
      <div className="max-w-6xl mx-auto grid grid-cols-1 gap-8 pb-20">
        {cards.map((card) => (
          <Flashcard key={card.id} data={card} />
        ))}
      </div>
    </div>
  );
};

// --- Reusable Components for the Flashcard ---

// 1. Tian Zi Ge (Rice Grid) Component
const TianZiGe = ({ char, size = "large", showChar = true, noBorder = false, customFontSize, showCross = true }) => { // Added showCross prop
  const borderColor = size === 'small' ? 'border-red-300' : 'border-red-400';
  
  if (noBorder) {
    // Return just the character without the grid
    return (
      <div className="relative box-border flex items-center justify-center w-full h-full">
        <div 
          className="flex items-center justify-center text-black font-serif"
          style={{ 
            fontSize: 'clamp(100px, 18vw, 220px)', 
            fontFamily: '"Noto Serif TC", "PMingLiU", "MingLiU", serif', 
            lineHeight: 1, 
          }}
        >
          {/* Added specific class for onclone targeting */}
          <span className="tian-zi-ge-text-span" style={{ display: 'block' }}>{char}</span>
        </div>
      </div>
    );
  }

  // Determine font size
  const fontSize = customFontSize || (size === 'small' ? '24px' : 'clamp(100px, 18vw, 200px)');

  return (
    <div className={`relative border border-red-600 bg-white box-border ${size === 'small' ? 'border-[1px]' : 'border-[3px]'}`} 
         style={{ aspectRatio: '1/1', width: '100%' }}>
      
      {/* Horizontal Dashed Line - Conditional Rendering */}
      {showCross && (
        <div className={`absolute top-1/2 left-0 w-full h-px border-t ${borderColor} border-dashed transform -translate-y-1/2`}></div>
      )}
      
      {/* Vertical Dashed Line - Conditional Rendering */}
      {showCross && (
        <div className={`absolute left-1/2 top-0 h-full w-px border-l ${borderColor} border-dashed transform -translate-x-1/2`}></div>
      )}
      
      {/* Character Container */}
      <div className="absolute inset-0 flex items-center justify-center z-10 w-full h-full">
        {showChar && char && (
          <span
            className="tian-zi-ge-text-span" // Class for download targeting
            style={{ 
              fontSize: fontSize, 
              fontFamily: '"Noto Serif TC", "PMingLiU", "MingLiU", serif',
              lineHeight: 1,
              display: 'block',
              textAlign: 'center',
            }}
          >
            {char}
          </span>
        )}
      </div>
    </div>
  );
};

// 2. Custom Zhuyin Display
const ZhuyinDisplay = ({ zhuyin }) => {
  const tones = ['ˊ', 'ˇ', 'ˋ', '˙'];
  let tone = '';
  let symbols = '';

  for (const char of zhuyin) {
    if (tones.includes(char)) {
      tone = char;
    } else {
      symbols += char;
    }
  }

  return (
    <div className="relative h-full flex items-center">
      <div className="text-4xl font-serif font-medium tracking-widest text-black" style={{writingMode: 'vertical-rl'}}>
        {symbols}
      </div>
      {tone && (
        <div className="absolute left-full top-1/2 transform -translate-y-1/2 ml-1 text-3xl font-serif text-black">
          {tone}
        </div>
      )}
    </div>
  );
};

// 3. Main Flashcard Component
const Flashcard = ({ data }) => {
  const boxStyle = { width: '5.5rem', height: '5.5rem' }; 

  return (
    <div className="flex justify-center">
      {/* Aspect Ratio Container - 15/9 */}
      <div 
        className="flashcard-container bg-white shadow-xl overflow-hidden flex border-2 border-gray-800"
        data-char={data.character}
        style={{
          width: '100%',
          maxWidth: '800px',
          aspectRatio: '15/9', 
        }}
      >
        {/* === Left Column (40%) === */}
        <div className="w-[40%] flex flex-col border-r-2 border-gray-800">
          
          {/* Top Left: Character & Zhuyin */}
          <div className="h-[50%] flex items-center justify-center p-4 border-b-2 border-gray-800 relative bg-white">
            <div className="flex items-center gap-2 w-full justify-center pl-2">
               {/* Big Character */}
               <div className="w-[65%] flex items-center justify-center aspect-square">
                 <TianZiGe char={data.character} size="large" noBorder={true} />
               </div>
               {/* Vertical Zhuyin */}
               <ZhuyinDisplay zhuyin={data.zhuyin} />
            </div>
          </div>

          {/* Bottom Left: Illustration */}
          <div className="h-[50%] p-4 bg-white flex items-center justify-center overflow-hidden">
             {data.imageUrl ? (
               <img 
                  src={data.imageUrl} 
                  alt="illustration" 
                  className="w-full h-full" 
                  style={{ 
                    objectFit: 'contain',
                    transform: 'scale(1.2)', 
                    transformOrigin: 'center center'
                  }}
               />
             ) : (
               <div className="flex flex-col items-center text-gray-300">
                 <ImageIcon size={40} />
                 <span className="text-xs mt-2">生成中...</span>
               </div>
             )}
          </div>
        </div>

        {/* === Right Column (60%) === */}
        <div className="w-[60%] flex flex-col">
          
          {/* Top Right: Practice Writing + Info */}
          <div className="h-[36%] border-b-2 border-gray-800 p-4 flex flex-col justify-center">
             <div className="flex items-center gap-2 mb-2">
               <Pencil size={18} className="text-gray-700" />
               <span className="font-bold text-gray-800 text-sm">練習寫生字</span>
             </div>
             <div className="flex items-center justify-between">
                {/* Two Practice Grids */}
                <div className="flex justify-start w-[55%] pl-4 gap-2">
                  <div style={boxStyle}>
                    <TianZiGe size="small" showChar={false} />
                  </div>
                  <div style={boxStyle}>
                    <TianZiGe size="small" showChar={false} />
                  </div>
                </div>
                {/* Info */}
                <div className="flex flex-col justify-center gap-2 text-black font-serif border-l border-gray-300 pl-6 w-[40%]">
                   <div className="flex items-baseline gap-2">
                      <span className="text-xl text-gray-600">部首:</span>
                      <span className="font-bold text-3xl">{data.radical}</span>
                   </div>
                   <div className="flex items-baseline gap-2">
                      <span className="text-xl text-gray-600">筆畫:</span>
                      <span className="font-bold text-3xl">{data.strokes}</span>
                   </div>
                </div>
             </div>
          </div>

          {/* Middle Right: Vocab Fill-in */}
          <div className="h-[32%] border-b-2 border-gray-800 p-4 flex flex-col justify-center bg-gray-50/30">
             <div className="flex items-center gap-2 mb-3">
               <Type size={18} className="text-gray-700" />
               <span className="font-bold text-gray-800 text-sm">語詞填空</span>
             </div>
             <div className="flex justify-around items-center">
               {data.words && data.words.slice(0, 2).map((word, idx) => {
                 return (
                   <div key={idx} className="flex items-center">
                     {word.split('').map((char, charIdx) => {
                       const isTarget = char === data.character;
                       return (
                         <div key={charIdx} style={boxStyle}>
                           <TianZiGe 
                             size="small" 
                             char={char} 
                             showChar={!isTarget} 
                             customFontSize="3.5rem"
                             showCross={false} // Removed cross lines for vocab
                           />
                         </div>
                       );
                     })}
                   </div>
                 );
               })}
             </div>
          </div>

          {/* Bottom Right: Find Character in Sentence */}
          {/* Added z-index to ensure it sits on top */}
          <div className="h-[32%] p-3 flex flex-col justify-start pt-2 sentence-container relative" style={{ zIndex: 50 }}>
             <div className="flex items-center gap-2 mb-1">
               <Search size={16} className="text-gray-700" />
               <span className="font-bold text-gray-800 text-xs">找出句子中的「{data.character}」字</span>
             </div>
             {/* Removed limiting box (overflow-hidden, border, etc.) */}
             <div className="flex-1 flex items-start"> 
               <p className="text-lg font-serif leading-normal text-gray-800 tracking-wide">
                 {data.sentence || "造句生成中..."}
               </p>
             </div>
          </div>

        </div>
      </div>
    </div>
  );
};

export default App;